# Chapter7 시스템 버스, I/O 및 인터럽트

# 시스템 버스

시스템 버스 : 컴퓨터 시스템의 구성 요소들을 상호연결해주는 중심 통로
* 이를 통해 정보(프로그램 코드, 데이터, 제어 명령 등) 교환 / 동작 시간을 조정하기 위한 클록 신호 전송
* 시스템 버스를 구성하는 선들의 수는 한 번에 전송하는 데이터 비트들의 수와 기억장치 주소 비트들의 수에 따라 결정
* 종류
    * 데이터 버스 : 데이터를 전송하는 데 사용되는 선들의 집합
    * 주소 버스 : 기억장치 주소를 지정하기 위한 주소를 전송하는 선들의 집합
    * 제어 버스 : 각각의 제어 신호 발생
        * 기억장치 쓰기 신호
        * 기억장치 읽기 신호
        * I/O 쓰기 신호
        * I/O 읽기 신호
* 버스 마스터 : 시스템 버스에 접속되는 요소들 중에서 버스 사용의 주체가 되는 요소들
    * 일반적인 컴퓨터에서는 CPU와 I/O 제어기 등
    * 동기식 버스를 사용하는 시스템에서는 기억장치 모듈
    * 한 순간에 한 개의 버스 마스터만 시스템 버스 사용 가능 -> 두 개 또는 그 이상의 
    마스터들이 동시에 버스를 사용하고자 할 때는 순서대로 사용하도록 버스 중재를 해주어야 함
       * 이 때 필요한 제어 신호
           * 버스 요구 신호
           * 버스 승인 신호
           * 버스 사용중 신호
       * 중재 버스 : 버스 중재 동작에 필요한 신호 선들의 집합
* 시스템 버스의 기본 동작
    * 쓰기 동작
        * 버스 마스터가 버스 사용권 획득
        * 버스를 통하여 주소와 데이터 및 쓰기 신호 보냄
    * 읽기 동작
        * 버스 마스터가 버스 사용권 획득
        * 주소와 읽기 신호를 보내고, 데이터가 전송되어 올 때까지 기다림
* 동기식 버스 : 시스템 버스에서 모든 버스 동작들이 발생하는 시간이 공통의 버스 클록을 기준으로 결정되는 버스
    * 인터페이스 회로가 간단하다는 장점
    * 반면, 버스 클록의 주기가 가장 오래 걸리는 버스 동작의 소요 시간을 기준으로 정해져야 하기 때문에 
    클록 주기보다 더 짧은 시간이 걸리는 버스 동작의 경우에는 동작이 완료된 후에도 다음 주기가 시작될 때까지 
    기다려야 함
    * 중형급 이상의 시스템에서 사용
* 비동기식 버스 : 버스 동작들이 발생하는 시간이 다른 버스 동작의 발생 여부에 따라 결정
    * 각 버스 동작이 완료되는 즉시, 연관된 다음 동작이 발생하므로 낭비되는 시간이 없음
    * 반면, 연속적인 동작들을 처리하기 위한 인터페이스 회로가 복잡해짐
    * 소규모 컴퓨터 시스템에서 사용

# 버스 중재

버스 경합 : 한 개의 시스템 버스에 접속된 여러 개의 버스 마스터들이 동시에 버스 사용을 요구하는 경우에는 경쟁이 발생
           적절히 해결하지 못하면 시스템이 정상적으로 동작하지 않거나 동작을 하더라도 성능이 떨어짐
버스 중재 : 버스 경합이 발생한 경우 버스 마스터들 중에서 한 개씩 선택하여 순서대로 버스를 사용할 수 있게 해주는 동작
버스 중재기: 버스 중재 기능을 수행하는 하드웨어 모듈

기능상 중요도가 높은 버스 마스터가 버스를 우선적으로 사용할 수 있도록 해주어야 함
동등한 우선순위라면 공정하게 버스를 사용할 수 있도록 해야하고 특정 버스 마스터가 매우 오랫동안 버스를 사용하지 못하는
기근(starvation) 현상이 발생하지 않도록 해야 한다.

버스 중재 방식
* 1) 연결 구조 기준
    * 병렬 중재 방식 : 각 버스 마스터가 독립적인 버스 요구 신호 선을 가짐 -> 이들 모두 중재 회로로 입력
    승인 신호도 각 버스 마스터에 대해 별도로 발생
    * 직렬 중재 방식 : 버스 요구 및 승인 신호 선이 각각 한 개씩만 있으며, 각 신호 선이 버스 마스터들 간에 직렬로 접속
* 2) 중재기의 위치 기준
    * 중앙집중식 중재 방식 
        * 시스템 내에 버스 중재기가 한 개만 존재 / 이 하나의 중재기가 요구를 받고 승인
    * 분산식 중재 방식
        * 여러 개의 버스 중재기들이 존재
        * 버스 중재 동작이 각 마스터의 중재기에 의해 이루어짐

위 버스 중재 방식을 적절히 조합하여 다양한 버스 중재 방식 구성 가능
* 1) 병렬 중재 방식
    * 중압집중식 고정-우선순위 방식 : 각 버스 마스터가 자신의 버스 요구 선을 가지고 있으며 이들 모두 하나의 버스 중재기로
    접속 -> 우선순위가 고정되어 있고 요구 신호를 보내는 마스터 중 우선순위가 가장 높은 마스터의 버스 승인 신호만 세트
    * 분산식 고정-우선순위 방식 : 모든 버스 마스터들이 중재기를 한 개씩 다 가지고 있고 각 버스 마스터의 중재기는 자신보다
    높은 우선순위를 가진 버스 마스터들의 버스 요구가 없을 때 승인 신호 세트
    * 가변 우선순위 방식 : 우선순위가 계속 바뀌어서 최상위 우선순위를 가지는 마스터가 독점하고 최하위 우선순위를 가지는 마스터가
    오랫동안 버스를 사용하지 못하는 기근 현상이 발생하는 것을 방지하기 위한 것
       * 회전 우선순위 : 한 번 사용하면 최하위 우선순위로 내려가고 다시 돈다. 아니면 한 중재동작이 끝날 때마다
       모든 마스터들의 우선순위가 한 단계씩 낮아지고 가장 우선순위가 낮았던 마스터가 최상위 우선순위를 가진다.
       * 임의 우선순위 : 중재동작 끝날 때마다 그냥 랜덤이다.
       * 동등 우선순위 : 비동기식 버스 시스템에서만 사용 / 모든 마스터는 동등한 우선순위 / 동시에 버스 요구 오면 
       정해진 기준에 의해 충돌 해결 ex) FIFO 알고리즘
       * 최소 최근 사용 우선순위(LRU) : 최근 가장 오랫동안 사용하지 않은 버스 마스터에게 최상위 우선순위를 할당 
* 2) 직렬 중재 방식
    * 중앙집중식 직렬 중재 방식 : 하나의 중재 신호선에 의해 모든 버스 마스터들이 직렬로 연결 / 버스 중재기를 
    시작점으로 하여 승인 신호 선이 연결된 순서대로 결정 / 결과적으로 버스 중재기에 가장 가까이 위치한 마스터가 
    가장 높은 우선순위 / 어떤 마스터가 사용하고 있으면 BBUSY 신호가 세트
    * 분산식 직렬 중재 방식 : 자신의 중재기를 각각 가지고 순환형으로 연결된다. 사용하는 순간 신호를 우측에 연결된 
    마스터의 신호기에 전달 / 원형으로 순환되어 연결되어 있기 때문에 연결된 순서대로 우선순위 하나씩 낮아짐
* 3) 폴링 방식(주기적 검사 방식) : 버스 중재기가 각 마스터들이 버스 사용을 원하는지를 주기적으로 
     검사하여 버스 승인 여부를 결정 
    * 하드웨어 폴링 방식 : 중재기 내의 고정된 하드웨어를 이용하여 주기적 검사를 통해 중재 기능을 수행
      별도의 폴링 선이 존재 / 2진 코드화된 폴링 주소를 사용하여 검사할 마스터 지정 / 중재기가 마스터를 
      검사하는 순서에 의하여 우선순위 결정
    * 소프트웨어 폴링 방식 : 버스 중재기 내부에 간단한 프로세서가 있어서 프로그램에 의해 중재 동작 진행
      속도는 더 느리지만 융통성 있는 중재 가능

# I/O 장치의 접속

I/O 장치는 시스템 버스에 직접 접속 불가
* why?
    * I/O 장치 매우 다양하고 제어하는 방법 다름
    * I/O 장치의 데이터 전송 속도가 CPU의 데이터 처리 속도에 비하여 훨씬 느림
    * I/O 장치들과 CPU가 사용하는 데이터 형식의 길이가 다른 경우가 많음

그래서 I/O 제어기가 필요
* 제어와 타이밍 조정
* CPU와의 통신 담당
* I/O 장치와의 통신 담당
* 데이터 버퍼링 기능 수행
* 오류 검출

한 제어기가 공통적으로 I/O 장치를 제어하는 것은 불가능 / 각 장치에 대해 별도의 제어기 존재

과정을 살펴보면
ex) CPU가 프린트 제어기에게 프린트의 상태를 검사하도록 요청 -> 제어기가 검사하여 CPU에게 알려줌
-> 준비되면 CPU는 제어기에 출력 명령과 데이터 전송 -> 제어기는 제어신호와 데이터를 프린터로 전송

프린터는 CPU에 비해 상당히 느린 장치이기 때문에 준비되었는지 상태를 검사하는 과정이 여러 번 반복될 
것인데 별도의 하드웨어는 필요 없지만 CPU가 I/O 동작에 전적으로 개입해야 하기 때문에 다른 일을 하지
못하는 단점이 있다.

사실 CPU는 I/O 장치를 제어할 필요가 전혀 없고 그 레지스터만 보일 뿐이다.

* I/O 주소지정
    * 기억장치 - 사상 I/O
        * I/O 레지스터들에 대해 기억장치와 동일하게 취급 즉 기억장치의 주소를 할당해줌
        * 단점은 기억장치 주소 공간에 I/O 장치를 할당하다 보니 기억장치 주소 공간이 
        상당히 줄어든다는 것
    * 분리형 I/O
        * 기억장치 주소공간과는 별도로 할당 -> 별도의 명령어 사용 / 기억장치에 대한 명령인지 
        I/O에 대한 신호인지 별도의 신호도 발생시켜야 함
        * 읽기/쓰기 두 명령어로만 제어해야 하므로 프로그램이 불편해지는 단점 존재

# 인터럽트를 이용한 I/O

프로그램을 이용한 I/O 방식은 CPU가 I/O에 계속 관여해야 하므로 CPU시간이 낭비됨
그러므로 다른 작업하다가 인터럽트 신호 받으면 수행하는 방식이 인터럽트를 이용한 I/O

인터럽트를 발생시킬 수 있는 장치가 여러 개 존재한다면?
* 다중 인터럽트 방식
    * 인터럽트 요구 신호선과 인터럽트 확인 신호선이 한 개씩 존재
    * 여러 개의 인터럽트 요구 신호가 발생한다면?
        * 우선순위를 정하고 더 높은 우선순위를 가진 장치의 인터럽트 요구부터 확인하고 서비스함
    * 별도의 인터럽트 선이 있기 때문에 요구한 장치 쉽게 찾을 수 있지만 하드웨어가 복잡해짐
* 데이지 체인 방식
    * 공유하고 있는 INTR 선이 연결된 순서가 우선 순위 
    * 하드웨어가 간단하지만 우선순위가 낮은 장치들이 서비스를 받지 못하고 계속 밀려날 수 있음
* 소프트웨어 폴링 방식
    * 인터럽트를 요구한 장치를 찾아내는 과정에서 마이크로 프로그램을 이용
    * 하드웨어가 간단하다는 장점이 있지만 검사를 위한 시간이 많이 걸리다는 단점도 존재

# DMA를 이용한 I/O

인터럽트를 이용한 I/O가 프로그램을 이용한 I/O보다 효율적이기는 하지만 그래도 CPU가 직접 개입해야 함
이러한 문제점을 해결하기 위해 직접 기억장치 액세스(DMA : Direct Memory Access)가 널리 사용됨

DMA : CPU가 개입하지 않고도 I/O 장치와 기억 장치 사이에 데이터 전송을 수행하는 메커니즘
DMA 제어기가 별도로 필요
* DMA 제어기 : DMA 동작을 수행하기 위해 시스템 버스를 통해 주기억장치를 액세스 -> 즉 CPU와 
시스템 버스 공유 / 대신 CPU가 시스템 버스를 사용하지 않는 시간만 이용 -> 그래서 DMA를 
사이클 스틸링(cycle stealing)이라고 부르기도 함

그런데 그러한 사이클만 큰 데이터 블록을 전송하는 경우 처리 시간 너무 길어짐 -> 일반적으로는 
CPU가 즉시 사용 허가를 해주어서 DMA 동작 일어나도록 하고 CPU는 기다림

DMA 동장은 주기억장치와 I/O제어기 사이에 데이터를 한 번에 한 개씩만 전송
ex) 디스크 쓰기 작업 
주기억장치 -> DMA제어기 -> 디스크 제어기
그래서 시스템 버스 2번 사용 -> 전체 시스템의 성능이 저하

그러므로 I/O 제어기를 DMA 제어기에 바로 연결하는 방법 사용
* 대신 접속시킬 수 있는 I/O 제어기의 수는 제한됨
* I/O 제어기가 다양해서 지원에 한계
* 데이터 클 때는 임시 버퍼도 필요

그래서 나온 것이 I/O 프로세서이고 최근 고성능 컴퓨터에서 사용됨
