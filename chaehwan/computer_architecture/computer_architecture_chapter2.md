# Chapter2 CPU의 구조와 기능

# CPU의 기본 구조

프로그램 수행을 위한 CPU의 동작 단계
* (1) 명령어 인출 : 명령어 읽어오기
* (2) 명령어 해독 : 수행동작 결정하기 위한 목적
* (3) 데이터 인출 : 명령어 수행에 데이터가 필요한 경우에만 수행 
* (4) 데이터 처리 : 데이터에 대한 산술적 혹인 논리적 연산 수행 
* (5) 데이터 저장 : 수행한 결과 저장 
( (3) ~ (5) : 필요한 경우에만 수행 ) 

프로그램 수행을 위한 CPU의 동작 단계와 CPU의 기본 구조 무관하지 않음

CPU의 구성 
* 산술논리연산장치(ALU) : 산술 연산들과 논리 연산들을 수행하는 회로들로 이루어진 하드웨어 모듈 ex) +,-, AND, OR
* 레지스터 세트(register set) : CPU 내부에 위치한 기억장치 / CPU가 가장 빠르게 액세스 가능한 장치
* 제어 유니트(control unit) : 명령어 해석 -> 제어신호 발생

# 명령어 실행

명령어 사이클 : 한 명령어를 실행하는 데 필요한 전체 과정
* 크게 인출 사이클(명령어 읽어오기) / 실행 사이클
그 과정에서 필요한 CPU의 내부 레지스터
* 프로그램 카운터(PC) : 다음 읽어올 명령어의 주소를 가지고 있는 레지스터
* 누산기(AC) : 데이터를 일시 저장
* 명령어 레지스터(IR) : 가장 최근에 인출된 명령어가 저장되어 있는 레지스터
* 기억장치 주소 레지스터(MAR) : PC에 저장된 명령어 주소가 시스템 주소 버스로 출력 전 일시 저장
* 기억장치 버퍼 레지스터(MBR) : 기억장치에 저장될 데이터 혹은 기억장치로부터 읽혀진 데이터가 일시적으로 저장

인출 사이클 : 기억장치의 지정된 위치로부터 명령어를 읽어오는 과정
실행 사이클 : CPU가 인출된 명령어 코드를 해독하고 그 결과에 따라 필요한 연산을 수행
인터럽트 사이클 : 순차적인 명령어 실행을 중단하고 다른 프로그램을 중단하고 다른 프로그램을 처리
* 인터럽트 처리를 위한 프로그램 : 인터럽트 서비스 루틴
* 다음 실행할 명령어 -> 스택에 복귀할 주소로 저장 -> 나중에 복귀
* 인터럽트를 받지 못하는 상태면 인터럽트 사이클 수행x
* 인터럽트 도중 인터럽트 가능 -> 다중 인터럽트
간접 사이클 : 어떤 명령어의 경우 데이터의 주소가 아니라 데이터가 저장된 기억 장소의 주소를 가리킴
* 실행 사이클이 시작되기 전에 그 데이터의 실제 주소 먼저 읽어와야 함
* 인출 사이클과 실행 사이클의 사이에 진행되는 과정
    * 특정 비트 ex) I비트 가 1로 세트된 경우에만 수행

# 명령어 파이프라이닝

CPU의 성능 => 프로그램 처리 시간에 직접적 영향
=> 속도를 더 향상시킬 수는 없을까? => 한 가지 방법이 "파이프라이닝"

명령어 파이프라이닝
* 공장 컨베이어 벨트에서의 공정에 비유
    * 다음 사람한테 넘어가면 할 일이 없음 -> 컨베이어 벨트 한 바퀴 돌고 물건 올리면 너무 비효율적
    * 하드웨어 모듈을 하나의 일꾼이라고 했을 때 그 시간마저 쉬게 하지 않겠다는 개념
    * 다음 모듈에 넘겨주면 바로 일거리 즉 명령어를 바로 가지고 오도록 하는 것

명령어 파이프라이닝의 종류
* 2단계 명령어 파이프라인 (인출 -> 실행)
    * 공정이 2단계만 있다고 생각하면 된다. (인출 / 실행)
    * 실행 단계가 더 오래 걸리기 때문에 인출 단계에서 실행 단계 속도를 맞추어 주어야 한다.
      -> 그래서 실제로 두 배만큼 속도가 향상되지는 않는다.  
* 4단계 명령어 파이프라인 (명령어 인출 -> 명령어 해독 -> 오퍼랜드 인출 -> 실행)
    * 2단계 명령어 파이프라인의 문제 : 처리 시간이 동일하지 않아서 효율 저하
    * 단계의 시간이 거의 비슷하도록 잘게 쪼개는 것 : 명령어 인출 -> 명령어 해독 -> 오퍼랜드 인출 -> 실행
    * 파이프라이닝을 통해 얻을 수 있는 속도 향상의 관계식 T = k * n -> T = k + (N-1)
        * 파이프라인 단계의 수 : k
        * 실행할 명령어의 수 : N
        * 전체 명령어의 실행 시간 : T
    * 한계도 분명히 존재
        * 1) 항상 4단계를 거치는 것은 아닌데 필요 없이 4개 단계를 수행하게 될 수 있음
        * 2) 파이프라인 클록은 처리 시간이 가장 오래 걸리는 단계를 기준으로 정해야 함
        * 3) 다른이 모듈이 같은 기억장치에 동시에 접근 시 충돌
        * 4) 조건 분기 실행 시 선인출 무효화
* 한계를 극복하기 위한 보완책도 존재
    * 슈퍼파이프라이닝 : 명령어 파이프라인의 단계를 더욱 잘게 분할하여 처리 속도를 높여주는 기술
    * 기억장치 액세스 충돌 방지를 위해 CPU 내부 캐시를 명령어 캐시와 데이터 캐시로 분리
    * 조건 분기의 경우
        * 분기 예측 : 분기를 예측해 어떤 경로의 명령어를 인출할 것인지 결정
        * 분기 목적지 선인출 : 분기를 인식하면 분기하게 될 목적지의 명령어도 선인출
        * 루프 버퍼 : 가장 최근에 인출된 일정 개수의 명령어들을 순서대로 저장해두고 분기 발생 시 
        버퍼부터 먼저 검사
        * 지연 분기 : 분기 명령어의 위치를 적절히 조정하여 나중에 실행되도록 재배치하여 성능 저하 최소화
* 분기 명령어에서 사용하는 조건들은 CPU 내부의 상태 레지스터에 저장
* 슈퍼 스칼라 : CPU의 처리 속도를 높이기 위해 내부에 두 개 이상의 파이프라인을 포함시킨 구조
    * 두 개의 파이프라인들로 이루어진 구조 -> 2-way 슈퍼스칼라
        * 매 주기마다 명령어가 두 개씩 인출되어 동시에 처리
    * 역시나 주의점은 동시에 처리할 명령어들이 서로 영향을 받지 않고 독립적으로 실행될 수 있어야 함
        * '데이터 의존성'이 존재하지 않아야 동시에 실행이 가능함
    * T(1) = k + N-1 -> T(m) = k + (N-m)/m
    * 충돌 방지를 위해 그만큼 하드웨어가 추가되어야 함
* 멀티 코어 
    * 서버급 컴퓨터 시스템에서는 프로그램 처리 속도를 높이기 위하여 한 시스템 내에 여러 개의 CPU를 
    탑재하는 다중 프로세서 구조를 널리 사용해옴
    * 반도체 기술의 발전으로 하나의 실리콘 칩에 더욱 많은 수의 회로들을 집적시킬 수 있게 됨  
      -> 하나의 칩에 두 개 혹은 그 이상의 CPU 코어들을 포함시킬 수 있게 됨
      (여기서 CPU코어는 기존 CPU 칩에 포함되던 하드웨어 중에서 명령어 실행에 필요한 핵심모듈을 말함)
    * 코어 여러 개를 하나의 칩에 넣은 것이 멀티 코어 -> 두 개 넣으면 듀얼 코어, 네 개 넣으면 쿼드 코어
    * 각각의 CPU 코어는 내부 캐시와 시스템 버스 인터페이스만 공유하고 프로그램을 독립적으로 수행
        * 필요한 경우에만 공유 캐시를 통해 정보를 교환 -> 파이프라인에 비하여 독립성이 더 높음
        * 분할된 태스크들이 CPU 코어에 의해 동시에 처리되므로 멀티 태스킹, 멀티스레딩과 같은 
        동시처리기술에 사용됨

# 명령어 세트

명령어 세트 : CPU를 위해 정의되어 있는 명령어들의 집합
* 연산 종류 : CPU가 수행할 연산들의 수의 종류와 복잡도 ex) 데이터 전송, 프로그램 제어
* 데이터 형태 : 데이터의 길이(비트의 수)와 수의 표현 방식(정수, 부동소수점 수) 등 
* 명령어 형식 : 명령어의 길이, 오퍼랜드들의 개수와 길이 등 - 연산 코드 ex) LOAD / 오퍼랜드 / 다음 명령어 주소 
    * 오퍼랜드 - 데이터 / 기억장치 주소 / 레지스터 번호
    * 오퍼랜드의 개수에 따라 1-주소 명령어 / 2-주소 명령어 / 3-주소 명령어
        * 1-주소 명령어 : LOAD A
        * 2-주소 명령어 : MOV R1, A
        * 3-주소 명령어 : MUL X, R1, R2
* 주소지정 방식 : 오퍼랜드의 주소를 지정하는 방식
    * 주소지정 방식에 따라 유효 주소인 EA가 결정 (유효 주소: 실제 데이터를 읽어오기 위한 주소)
    * 직접 주소지정 방식 : 오퍼랜드 필드의 내용이 유효주소 -> 오퍼랜드 필드의 비트의 수에 의해 기억장치 주소 공간 제한
    * 간접 주소지정 방식
        * 직접 주소지정 방식의 문제점 : 기억장치 범위가 제한됨 -> 오퍼랜드 필드의 기억장치 주소가 가리키는 기억 장소에
        데이터의 유효 주소를 저장 -> 최대 기억장치 용량이 그 기억 장소에 저장된 전체 비트 수에 의해 결정되므로 범위 더
        크게 활용 가능
        * I 비트가 set되어 있는지 여부에 따라 결정 가능
        * 단점은 실행 사이클 동안 2번의 기억장치 액세스가 필요(첫번째: 주소 / 두번째: 실제 데이터)
    * 묵시적 주소지정 방식 : 명령어 실행에 필요한 데이터의 위치를 지정하지 않더라도 이미 묵시적으로 결정
        * ex) 자동적으로 스택에 저장하는 PUSH 명령어
    * 즉시 주소지정 방식 : 명령어 코드 자체가 '연산코드/데이터'구조로 별도의 데이터 인출 과정 필요 없음
        * 변수의 초기 값을 어떤 상수값으로 세트하는 데 주로 사용
        * 장점은 데이터 별도로 인출할 필요가 없어서 실행 사이클이 짧아진다는 것이고, 단점은 사용할 수 있는 수의 크기가
        오퍼랜드 필드의 비트 수에 의해 제한된다는 점  
    * 레지스터 주소지정 방식 : 연산에 사용될 데이터가 이미 레지스터에 저장되어 있어서 오퍼랜드 필드의 내용에는 레지스터 번호가 저장됨
        * 사용될 수 있는 레지스터의 수가 오퍼랜드 필드의 비트 수에 의해 결정
        * 장점은 오퍼랜드 필드의 비트 수가 적어도 되고 데이터 인출을 위해 별도의 액세스 시간 필요 없다는 것 대신 데이터가 저장될 수 있는 위치도 CPU 내부 레지스터로 제한
    * 레지스터 간접 주소지정 방식 : 레지스터의 내용이 기억장치의 주소로 사용
        * 레지스터의 길이만큼 주소 지정 가능하지만 한 번의 데이터 액세스 필요
    * 변위 주소지정 방식 : 직접 주소지정방식과 간접 주소지정방식의 조합 -> 유연성이 높아짐
        * 두 개의 오퍼랜드를 가짐 -> 하나는 변위를 나타내는 주소A, 하나는 레지스터 번호R
        * R이 가리키는 내용을 A와 더해 유효주소 결정
            * 상대 주소지정 방식 : PC의 내용에 A를 더해 유효주소 결정
                * 변위는 그 명령어의 위치를 기준으로 한 상대적인 값
                * 분기 명령어에 주로 사용
                * 변위의 범위가 오퍼랜드 필드의 비트 수에 의하여 제한되지만, 전체 기억장치 주소가 명령어에 포함되어야
                하는 일반적인 분기 명령어보다 적은 수의 비트만 있으면 된다는 장점이 있음
            * 인덱스 주소지정 방식 : 인덱스 레지스터의 내용과 변위 A를 더하여 유효 주소 결정
                * 일반적으로 A는 데이터 배열의 시작 주소를 가리키고, 인덱스 레지스터의 내용은 그 배열의 시작주소로부터 
                각 데이터까지의 거리를 나타냄 -> 순차적으로 액세스 가능(자동 인덱싱)
            * 베이스 레지스터 주소지정 방식 : 베이스 레지스터의 내용에 A를 더하여 유효주소 결정
                * 베이스 레지스터에는 기준이 되는 명령어가 저장되므로 프로그램의 시작 위치를 지정하는 데 사용됨
                * 다중프로그래밍 시스템에서는 베이스 레지스터의 내용만 이동될 위치의 시작 주소로 변경하면 됨


