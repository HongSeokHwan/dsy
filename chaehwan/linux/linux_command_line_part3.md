# The Linux Command Line Part3 - 기본 작업과 필수 도구

# Chapter14. 패키지 관리

패키지 관리 : 시스템에 소프트웨어를 설치하고 유지 및 관리하는 방법

참고) 패키지 시스템
* 리눅스 배포판마다 다른 패키지 시스템 운영
    * 데비안 스타일 ex) Debian, Ubuntu
    * 레드햇 스타일 ex) Fedora, CentOS
* 특정 배포판을 위해 만들어진 패키지는 다른 배포판과 호환되지 않음

## 패키지 시스템 동작원리

* 대부분의 소프트웨어를 인터넷에서 다운로드
* 패키지 파일 : 소프트웨어의 가장 기본적인 단위
              (소프트웨어 패키지를 구성하고 있는 파이들의 압축된 형태)
* 저장소 : 메인 저장소에 단일 배포판 사용자만을 위한 수많은 패키지가 보관됨
* 의존성 : 프로그램 작업을 수행하기 위해서는 다른 소프트웨어 구성요소에 의존하게 됨
          -> 패키지가 설치될 때, 해당 패키지와 관련된 모든 의존적인 구성요소들까지 
            설치되도록 하는 등의 방법 사용하여 의존성 문제 해결
* 저수준과 고수준 : 저수준은 패키지를 설치/삭제하고, 고수준 툴은 메타데이터 검색 및
                   의존성 문제 해결

## 일반적인 패키지 관리 작업

### 저장소에서 패키지 찾기

* debian

```bash
apt-get update
apt-cache search_string
```

* redhat

```bash
yum search search_string
```

### 저장소에 있는 패키지 설치하기

* debian

```bash
apt-get update
apt-get install package_name
```

* redhat

```bash
yum install package_name
```

### 패키지 파일에서 패키지 설치하기

저장소가 아닌 다른 출처에서 다운로드한 패키지 파일이라면 저수준 도구를 이용해서 
직접 설치할 수 있다.(의존성 문제 해결 불가)

* debian

```bash
dpkg --install package_file
```

* redhat

```bash
rpm -i package_file
```

### 패키지 삭제하기

* debian

```bash
apt-get remove package_name
```

* redhat

```bash
yum erase package_name  
```

### 저장소로부터 패키지 업데이트하기

* debian

```bash
apt-get update
apt-get upgrade
```

* redhat

```bash
yum update
```

### 패키지 파일에서 패키지 업그레이드하기

* debian

```bash
dpkg --install package_file
```

* redhat

```bash
rpm -U package_file
```

### 설치된 패키지 확인하기

* debian

```bash
dpkg --list
```

* redhat

```bash
rpm -qa
```

### 패키지 설치여부 알아보기

* debian

```bash
dpkg --list
```

* redhat

```bash
rpm -qa
```

### 설치된 패키지 정보 표시하기

* debian

```bash
apt-cache show package_name 
```

* redhat

```bash
yum info package_name
```

### 특정 파일과 관련된 패키지 검색하기

* debian

```bash
dpkg --search file_name
```

* redhat

```bash
rpm -qf file_name
```

# Chapter15. 저장 장치

## 저장 장치  마운트하기와 해제하기

* 저장 장치 관리에 있어 첫 번째로 해야 할 작업 : 파일 시스템 트리에 장치를 연결하는 것
  이러한 과정을 마운트한다 즉 장착한다고 말함(장치가 운영체제와 연결되는 과정)
* 리눅스는 여러 지점에서 장착된 장치라도 단일의 파일시스템 트리로 관리됨
    * 윈도우의 경우 C드라이브, D드라이브처럼 나누어짐

mount 명령어
* 파일시스템을 마운트할 때 사용
* 명령 인자 없이 단독으로 명령어를 입력하며 현재 마운트된 모든 파일 시스템 목록 보여줌

최신 리눅스 배포판들의 경우 CD-ROM을 삽입하면 자동 마운트됨

umount 명령어
* 슈퍼유저 권한 필요
* 마운트를 해제하는 명령어

```bash
su -
>
umount /dev/hdc
```

새로운 마운트 포인트 지정 가능

```bash
mkdir /mnt/cdrom
```

* 마운트 포인트란 별다른 것이 아닌 파일 시스템 어딘가에 있는 디렉토리를 의미
* 빈 디렉토리가 아니여도 상관 없음
* 디스크 마운트가 해제될 때까지 해당 디렉토리가 가지고 있는 기존의 내용 볼 수 없음

```bash
mkdir -t iso9660 /dev/hdc /mnt/cdrom
cd /mnt/cdrom
ls
umount /dev/hdc
> /mnt/cdrom : device is busy
cd
umount /dev/hdc
```

* mount할 때 -t 옵션을 주면 파일 시스템 타입을 설정할 수 있음
* mount point로 이동한 후 umount하려고 하면 오류 메세지가 발생
    * 장치가 다른 사용자나 프로세스에 의해 사용 중이라면 장치의 연결을
    해제할 수 없다는 뜻 -> 이유는 현재 CD-ROM 마운트 포인트로 작업 
    디렉토리를 변경했기 때문
    * 작업 디렉토리를 옮겨주면 문제가 해결됨

마운트 해제가 필요한 이유
* 시스템의 성능을 저해하는 장애요인 중 하나가 느린 장치들 ex) 프린터
* 그래서 존재하는 것이 버퍼 -> 바쁜 CPU가 기다리지 않아도 됨
* 마운트 해제 시 아직 저장되지 않은 데이터 -> 장치에 모두 쓰게 됨
  -> 안전하게 장치 제거 가능

## 새로운 파일시스템 만들기

### fdisk로 파티션 설정하기

* 장치의 파티션을 수정/삭제/생성 가능
* ex) sudo fdisk /dev/sda
* 첫 번째로 해야 할 일은 기존 파티션 레이아웃을 확인하는 것
    * p를 입력하여 장치의 파티션 테이블 출력

### mkfs로 새 파일 시스템 만들기

mkfs : make filesystem


# Chapter16. 네트워킹

## 네트워크 점검 및 모니터링

### ping : 네트워크 호스트로 고유 패킷 전송하기

* 가장 기본적인 명령어
* ex) ping linuxcommand.org
* 고유의 네트워크 패킷을 지정된 호스트로 전송
  -> 수신하는 대부분의 네트워크 장비들을 이에 응답하여 네트워크 연결 확인
* 명령이 실행되면 ping은 패킷의 중단이 없는 한 지정된 간격(기본적으로 1초)에 따라
  계속 전송
* Ctrl + c 로 연결 중단하면 네트워크 성능 현황을 확인 가능

### traceroute : 네트워크 패킷 경로 추적하기

* 로컬 시스템부터 지정된 호스트까지의 모든 네트워크 이동 "구간(hop)들"을 보여줌
* ex) traceroute github.com
* 라우터를 식별할 수 없는 경우 ***와 같이 표시

### netstat : 네트워크 설정 및 통계 정보 확인하기

* 다양한 네트워크 설정 사항이나 통계 정보를 확인하는 데 사용
* -ie : 시스템의 네트워크 인터페이스 정보 확인 가능
* ex) netstat -ie
* 일반적으로 네트워크 진단 작업을 수행할 때, 중요한 것
    * 각 인터페이스 정보 중 4번째 줄의 시작인 UP라는 단어의 존재 여부 
      -> 네트워크 인터페이스가 현재 활성화된 상태
    * inet addr 필드 -> 유효한 IP 주소인지 확인
* -r 옵션을 활용하면 네트워크 라우팅 테이블 정보 확인 가능
    * 패킷 송신을 위한 네트워크 설정 확인 가능
    * Gateway(게이트웨이) 필드 : 게이트웨이(라우터)의 IP 주소나 이름을 담고 있음
      별표가 있다는 것은 여기서 게이트웨이가 필요하지 않다는 것을 의미함

## 네트워크로 파일 전송하기

### ftp : 파일 전송 프로토콜로 파일 전송하기

* 네트워크에서 사용되는 프로토콜인 파일 전송 프로토콜(ftp)에서 이름을 따온 것
* 네트워크상에서 업로드 및 다운로드를 위해 파일을 저장하고 있는 FTP 서버와 통신
* FTP(본래의 형식) -> 보안에 취약
    * why? 계정 정보가 암호화되지 않은 채로 전송 -> 누구든 그 정보를 쉽게 볼 수 있음
      이런 이유로 FTP를 이용할 땐 익명 서버를 사용
      -> 익명의 사용자명과 의미 없는 비밀번호 사용하여 로그인

참고) 향상된 ftp인 lftp도 존재

### wget : 비대화식 네트워크 다운로더

* 단일 파일이든 다중 파일이든 혹은 사이트 전체까지도 다운로드 가능
* ex) wget http://linuxcommand.org/index.php
* 옵션을 통해 반복적인 다운로드도 가능

## 원격 호스트와 안전하게 통신하기

* 과거 원격 호스트에 접속하는 프로그램 많았지만 암호화되지 않은 채로
  통신한다는 이유로 사용하기가 굉장히 부적절했음
  -> ssh(안전한 shell) 등장

### ssh : 원격 컴퓨터에 안전하게 로그인하기

* ex) ssh remote-sys
* 원격 호스트와의 통신에서 중간자 공격을 방지
* 로컬과 원격 호스트 간의 모든 통신을 암호화
* 다른 사용자명으로 원격 시스템에 연결하는 것도 가능
* 원격 시스템의 shell 세션이 열리면, 명령어 실행 가능
    * ex) ssh remote-sys 'ls *' > dirlist.txt
* SSH 터널링 : SSH로 원격 호스트와 연결 -> 로컬 시스템과
  원격 시스템 간에 암호화된 터널 생성
  * 기본적인 기능에 더해 VPN(가상사설망)을 생성하여 
  네트워크 트래픽의 대다수 형식이 암호화된 터널을 통해 전송되는
  것을 지원


### scp와 sftp : 안전하게 파일 전송하기

* OpenSSH 패키지에는 두 프로그램 있음
    * scp(보안 복사) : cp 프로그램과 거의 유사하게 사용 가능
        * 대상이 되는 정보 앞에 원격 호스트명과 콜론 기호
        * ex) scp remote-sys:document.txt .
    * sftp(ftp 프로그램의 보안이 향상된 버전)
        * ftp 프로그램과 유사하지만 평문 대신 SSH로 암호화된 터널 사용
        * SSH 서버만 있으면 됨

# Chapter17. 파일 검색

## locate : 손쉽게 파일 찾기

* 경로명에 대한 빠른 데이터베이스검색을 수행하고 주어진 조건에 일치하는 모든 이름 출력
* ex) locate bin/zip
* 만약 검색조건이 간단하지 않다면, locate를 다른 명령어나 옵션과 함께 사용하여 검색조건을
  만드는 것도 가능하다.
  * ex) locate zip | grep bin

## find : 다양한 방법으로 파일 찾기

* locate가 오로지 파일명으로 파일을 찾을 수 있었다면 find는 
  다양한 속성을 가지고 파일을 찾는다.
* ex) find ~ (홈 디렉토리 내용 검색)
* 파이프라인을 이용해서 다른 프로그램과 함께 사용 가능
* ex) find ~ | wc -l
* find는 테스트, 액션, 옵션을 적용하여 검색 가능

테스트
* ex) find ~ -type d | wc -l
    * -type d라는 테스트를 추가해서 디렉토리 검색으로 제한
    * 일반 파일만 검색하는 것도 가능
        * ex) find ~ -type f | wc -l
    * 파일 형식
        * b : 블록 특수 파일
        * c : 문자 특수 파일
        * d : 디렉토리
        * f : 파일
        * l : 심볼릭 링크 파일
* ex) find ~ -type f -name "*.JPG" -size +1M | wc -l
* 테스트의 예 ex) -name, -size, -type, -perm 등등

연산자
* 테스트 간의 논리적인 관계를 설명하기 위해 논리 연산자 지원
* ex) find ~ \(-type f -not -perm 0600 \) -or \( -type d -not -perm 0700 \)
* 연산자의 예 ex) -and, -or, -not, ()

액션
* 테스트와 연산자로 목록을 뽑아낼 수 있지만 결국 그 목록에 대해 어떤 작업을
  해야주어야 하는 것이다. 이 때 필요한 것이 '액션'
* ex) find ~ -print
* ex) find ~ -type f -name '*.BAK' -delete
* find의 액션의 예
    * -delete, -ls, -print, -quit
* 사용자 정의 액션도 가능하다.
    * -exec command {} ;
    * ex) find ~ type f -name 'foo*' -ok ls -l '{}' ';'
옵션 
* find의 검색 범위를 설정할 때 사용
    * -depth : 디렉토리 자체 이전에 디렉토리의 파일에 대하여 find를 우선 실행
    * -maxdepth levels : 디렉토리 최대 탐색 깊이
    * -mindepth levels : 디렉토리 최소 탐색 깊이
    * -mount : 마운트된 디렉토리의 탐색은 제외

# Chapter18. 파일 보관 및 백업

컴퓨터 시스템을 관리하는 데 있어 가장 기초적인 작업 중 하나
-> 바로 시스템의 데이터를 안전하게 유지하는 것

이 작업을 위한 하나의 방편으로 주기적으로 시스템 파일을 백업하는 것

## 파일 압축하기

데이터 압축 -> 불필요하거나 중복된 데이터를 제거하는 과정
ex) 하나의 색상으로 된 이미지 -> 전체가 다 중복된 데이터

압축 알고리즘
* 무손실 : 원본 그대로를 유지하는 방식
* 손실 : 압축이 수행될 때 데이터 일부를 삭제(압축율을 더 높이기 위해)
  ex) JPEG, MP3

### gzip : 파일 압축 및 압축 해제하기

foo.txt -> gzip foo.txt(압축) -> foo.txt.gz -> gunzip foo.txt(압축 해제)

gzip 옵션 
ex)
-t : 압축 파일의 무결성 검사
-v : 압축되는 과정을 자세히 표시
-d : 압축 해제

참고) 

```bash
zcat foo.txt..gz | less
```
위와 같이 명령어를 입력하면 gunzip -c와 같은 작업을 실행 가능하다.
압축 파일에 대해서 cat 명령어를 사용하는 셈이다.

### bzip2 : 속도는 느리지만 고성능 압축 프로그램

gzip과 같은 방식으로 사용 가능

## 파일 보관하기(아카이빙)

압축 작업과 함께 주로 사용되는 파일 관리 작업은 파일 보관 작업이다.
-> 아카이빙 : 많은 파일들을 모아서 하나의 큰 파일로 묶는 과정
   시스템 백업의 일환으로 종종 수행되는 작업

일종의 장기 보관용 저장 장치에 오래된 데이터를 옮길 때 필요한 작업

### tar : 데이프 아카이빙 유틸리티

tar -> tape archive의 준말 / 백업 테이프를 만들기 위한 도구에서 유래
       하지만 다른 저장 장치에서도 잘 사용
* 형식
    * tar mode[options] pathname...
    * mode (-가 필요 없음)
        * c : 파일과 디렉토리의 목록에서 아카이브 생성
        * x : 아카이브 해제 
        * r : 아카이브 끝에 지정된 경로명을 덧붙이기
        * t : 아카이브 내용 보기

### zip : 파일을 묶고 압축하기

리눅스에서는 gzip, bzip2가 지배적이고, zip은 윈도우 시스템과 파일을
교환할 때 사용

* 형식
    * zip options zipfile file ...
    * ex) zip -r playground.zip playground
        * -r 옵션을 주어야 디렉토리가 재귀적으로 압축이 된다.
* unzip으로 압축을 해제할 수 있다.
* zip 프로그램의 경우 기존 아카이브 파일이 지정되면 파일 자체가 교체되는 것이
아니라 업데이트된다는 점이다.
* 기존의 아카이브는 유지되면서 새로운 파일은 추가되고 중복된 파일은 교체된다.

## 파일 및 디렉토리 동기화

시스템의 백업본을 관리하는 일반적인 방법은 하나 이상의 디렉토리를 또 다른
디렉토리와 동기화하여 로컬 시스템이나 원격 시스템에 저장하는 것
ex) 개발 중인 웹사이트의 로컬 복사본 만들고 원격 웹 서버에 주기적으로 동기화

### rsync : 원격 파일 및 디렉토리 동기화

* rsync remote-update protocol을 이용하여 로컬과 원격 디렉토리를 모두 동기화
* rsync options source destination
* source와 destination 에는 다음 중 하나가 올 수 있음
    * 로컬 파일이나 디렉토리
    * 원격 파일이나 디렉토리
    * 특정 형식의 URI로 지정된 원격 rsync 서버
* source나 destination 둘 중 하나는 반드시 로컬 파일이어야 한다.
* rsync의 r은 remote / rsync의 진면모는 네트워크상에서도 파일을 복사할 수 있다는 점
    * rsync 프로그램이 설치되어 있고 ssh와 같은 원격 셀 프로그램이 동작하고 있는
    다른 시스템으로 복사하는 것
    * rsync server를 이용하여 네트워크 상에서 동기화


# Chapter19. 정규 표현식

## 정규 표현식이란?

* 정규 표현식 : 텍스트에서 패턴을 인식하는 심볼 표기법
* shell의 와일드 카드와 유사하지만 더 큰 개념
* 텍스트 조작 문제의 해결을 용이하게 하므로 많은 커맨드 라인 툴과
  프로그래밍 언어에서 제공
  * 주의할 것은 툴과 프로그래밍 언어마다 조금씩 다르다

## grep : 텍스트를 통한 검색

* grep : global regular expression print란 구절에서 유래
  -> 정규표현식과 상당한 관련 있음 
  -> 정규 표현식과 일치하는 표준 출력을 가진 행을 출력 
* ex) ls /usr/bin | grep zip
* grep의 형식 : grep [options] regex [file...]
* grep의 옵션
    * -i : 대소문자 무시
    * -v : 반전 매치 즉 일치하지 않는 행 출력
    * -c : 일치한 행 자체가 아니라 행의 수 출력
    * -l : 일치한 행 자체가 아니라 이를 포함한 
           각각의 파일 이름을 출력
    * -L : 일치하는 행이 없는 파일명 출력
    * -n : 일치하는 행 앞에 파일의 행 번호 붙임
    * -h : 복수 파일 검색에서 파일명의 출력 숨김

## 메타 문자와 리터털

* ex) bzip -> 상수 문자
* 정규 표현식은 리터럴 외에도 메타문자 포함 가능
* 정규 표현식 메타 문자
    * ^ $ . [ ] { } - ? * + ( ) | \

## 모든 문자

* .(점)은 어떤 문자든지 일치한다.
* 정규 표현식에 포함하면 그 문자 위치의 어떤 문자든 일치할 것이다.

## 앵커

* 아래 두 문자는 앵커로 처리된다. 즉 해당 정규 표현식의 행의 시작이나 행의 끝에서
  발견되는 경우에만 일치하게 된다는 것이다.
  * ^ : 행의 시작
  * $ : 행의 끝

## 괄호 표현식과 문자 클래스

* 괄호 표현식 : 문자 집합의 한 문자와 일치하는지 확인 가능
  -> 비교할 문자 집합을 지정할 수 있음
* 집합 안에는 여러 문자들을 포함할 수 있고 괄호 안에 놓인 메타 문자들은 본래의 특수한 의미를
  잃어버림
* 메타문자가 괄호 안에서 다른 의미로 사용되는 경우 있음
    * ^ : 부정 (괄호 표현식의 첫 번째 문자인 경우에만)
    * \- : 문자의 범위 ex) [A-Z]

## POSIX 기본 vs 확장 정규 표현식

POSIX는 정규 표현식을 구현하는 방법을 두 가지로 구분
* 기본 정규 표현식(BRE)
* 확장 정규 표현식(ERE)

BRE와 ERE의 차이점 : 메타문자

BRE의 메타문자 : ^ $ . [ ] * (그 외 문자는 리터럴 문자로 인식)
( ( ) { } 기호는 백슬래시가 항상 함께 쓰여야만 메타 문자로 인식)  
ERE의 메타문자 : ^ $ . [ ] * ( ) { } ? + | 

## Alternation

* 확장 정규 표현식의 기능
* 표현식 집합 가운데에서 일치하는 것을 찾아주는 기능
* 괄호 표현식의 경우 여러 지정된 문자들 사이에서 일치하는
  한 문자를 허용한다.
* Alternation의 경우 문자열 집합이나 다른 정규 표현식에서
  일치하는 것을 찾는다.
* ex) echo "AAA" | grep -E 'AAA|BBB|CCC'
* 확장 기능이기 때문에 -E 옵션을 준다.
* 정규 표현식을 따옴표로 감싸는 것은 수직 파이프 메타문자를
  파이프 연산자와 헷갈리는 것을 방지하기 위해서다.
* ex) grep -Eh '^(bz|gz|zip)' dirlist*.txt
* 위와 같이 다른 정규표현식 요소들과 결합하려면 () 기호로
  Alternation을 구분해주면 된다.
* 위의 예는 정규 표현식 요소들을 결합시켜 bz, gz, zip으로
  시작하는 파일명을 찾으라는 의미를 가지게 된다.

## 수량 한정자

* 확장 정규 표현식의 기능
* 하나의 요소를 찾는 횟수를 지정하는 여러 방법을 지원

### ? : 항목이 없거나 한 번만 나타나는 경우

* ? 한정자의 의미는, "그 앞의 요소는 선택적인 것이다."라는 의미
* 예를 들어 전화번호의 경우 지역번호는 입력하는 경우가 있고 생략
  하는 경우가 있다. 그래서 정규표현식을 만든다면 아래와 같이 작성
  하는 것이 가능하다.
  ^/(?[0-9][0-9][0-9]\)? [0-9][0-9][0-9]-[0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]$
* 괄호 기호 다음에 물음표를 사용하여 없거나 한 번만 일치하는 것을 
  찾도록 지정하고 있다.

### * : 항목이 없거나 여러 번 나타나는 경우

* \* 기호는 임의의 사항을 입력할 때 사용
* ? 기호와 달리 여러 번 나타날 수 있음

### + : 항목이 한 번 이상 나타나는 경우

* \*와 거의 비슷하다.
* 찾으려는 요소와 일치하는 개체가 하나 이상 있어야 한다.
  (즉 없으면 안 된다)

### {} : 항목이 지정된 횟수만큼 나타나는 경우

* 검색 횟수의 최소와 최대값을 지정할 때 사용
* {n} : 정확히 n번만 일치하는 선행 요소 검색
* {n,m} : 최소 n번, 하지만 m번 미만으로 일치하는 선행 요소 검색
* {n,} : n번 이상 일치하는 선행 요소 검색
* {,m} : m번 미만 일치하는 선행 요소 검색

ex) 전화번호
^\([0-9]{3}\)? [0-9]{3}-[0-9]{4}$


# Chapter20. 텍스트 편집

리눅스는 텍스트 파일에 상당히 의존적이고 텍스트를 처리하는 것은 그러므로
상당히 중요하다.

## cat, sort, uniq 

### cat : 파일과 표준 출력을 연결

cat은 파일을 표준 출력에 연결하는 명령어다.
cat에는 흥미로운 옵션이 많다.
* -A : 비출력 문자를 표시한다. ex) 개행문자, 탭문자
    * ex) cata -A foo.txt
    * \> ^IThe quick brown fox jumped over the lazy dog.$
      -> 여기서 ^I는 Ctrl + I 를 의미하고 Tab과 동일하다.
      -A 옵션을 주었기 때문에 결과에 보인다.
* -n : 줄 번호 매기기
* -s : 여러 줄의 공백을 제거(확인해보면 한 줄만 남는다.)

### sort : 텍스트 파일의 행을 정렬

sort는 표준 입력이나 커맨드라인에 명시된 하나 이상의 파일의
내용물들을 정렬하고 표준 출력으로 결과를 전달한다.

형식은 다음과 같다.

sort file1.txt file2.txt file3.txt > final_sorted_list.txt

sort도 재미있는 옵션이 많다.
* -n : 숫자값으로 정렬
    * ex) du -s /usr/share/* | sort -nr | head
        * du에 -s 옵션을 줘서 디스크 사용량을 기준으로 출력한다.
        * head로 처음 10줄만 결과를 표시할 것인데 sort 명령어를
        사용해서 가장 사용량이 큰 10줄을 출력할 것이다.
        * 이 때 n옵션을 사용해서 사용량을 기준으로 정렬할 수 있고
        r 옵션을 같이 줘서 가장 큰 사용량부터 출력할 수 있다.
* -r : 역순 정렬
* -k : 특정 필드를 기준으로 정렬
    * ex) ls -l /usr/bin | sort -nr -k 5 | head
    * ls -l /usr/bin의 내용을 정렬하는데 -k 5이면
    ls -l /usr/bin으로 출력되는 결과물의 5번째 필드를
    키 필드로 해서 정렬을 수행하겠다는 뜻이다. 나머지
    옵션은 이전과 같다.
    * 정렬 key는 여러 개를 명시해줄 수 있다.
    * ex) sort --key=1,1 --key=2n distros.txt
    * 날짜 데이터는 어떻게 정렬할까?
    * a   10  11/25/2008
      b   5   03/20/2006
      c   9   03/20/2006
    * ex) sort -k 3.7nbr -k 3.1nbr -k 4nbr sort_test.txt
    * 위와 같은 방식으로 정렬하면 된다. 3.7은 3번째 필드의 7번째
    문자를 이야기하고 3.1은 3번째 필드의 1번째 필드를 이야기한다.
* -t : 필드를의 구분자를 공백 대신 설정할 수 있다.
    * ex) sort -t ':' -k 7 /etc/passwd | head
* -u : 중복 제거

### uniq : 중복행 생략 및 보고

```bash
ex)
a
b
c
a
b
c
```

```bash
uniq foo.txt
```

주의사항 : 파일 내용이 위와 같다고 했을 때 uniq 명령어를 적용하면
중복 내용이 제거되지 않는다.
-> uniq를 적용하려면 내용이 정렬되어 있어야 한다.

```bash
sort foo.txt | uniq
```

-c 옵션을 주면 중복 발생 횟수와 중복 행의 목록을 출력할 수 있다.

```bash
sort foo.txt | uniq -c
```

## 텍스트 자르고 붙이기

### cut : 파일들의 각 행 일부를 삭제

cut 명령어는 행에서 텍스트 일부를 추출하고 그 부분을 표준 출력으로 보낸다. 복수의 파일 인자나
표준 입력으로부터 입력을 허용한다.

-f 옵션을 주면 탭이나 ,로 구분한 하나 이상의 필드를 추출해낼 수 있다.
ex) cat -f 3 cut_test.txt
(스페이스로 된 공백은 안 된다.)

```bash
cat -A cut_test.txt 
```

a^I10^I12/25/2006$
b^I11^I11/12/2008$
c^I9^I10/22/2012$

위의 상황에서 아래의 결과를 가지고 온다.

12/25/2006
11/12/2008
10/22/2012

-c 옵션을 주면 숫자 범위로 정의한 영역을 잘라온다.

```bash
cut -f 3 cut_test.txt | cut -c 7-10
```

2006
2008
2012

-d 로 구분자를 ':' 등으로 설정해주는 것도 가능하다.

### paste : 파일들의 행을 합친다

* cut의 반대 명령어다. 
* cut이 하나 이상의 텍스트 열을 추출하는 대신, 파일에 하나 이상의
텍스트 열을 추가한다.
* 복수의 파일을 읽어 들이고, 각 파일에서 찾은 필드를 표준 출력의 
단일 스트림으로 결합한다.
* cut과 유사하게, paste는 복수의 파일 인자와 표준 입력을 받아들인다.

```bash
cut -f 1 2 sample.txt > info.txt
cut -f 3 sample.txt > date.txt
paste info.txt date.txt
```

연습으로 이미 잘 있던 컬럼 3개를 2개 있는 파일과 날짜 데이터만 있는 
하나의 파일로 갈라낸 다음 paste로 합치면 원상복귀가 된다.
반대 연산이기 때문에 결과가 동일하다.

### join : 공통 필드로 두 파일의 행을 합친다.

* 공유키 필드를 기준으로 복수의 테이블을 합친다.
* 관계형 데이터베이스에서의 join으로 생각하면 된다.
* 옵션을 이용해서 변경할 수 있지만 기본적으로 입력 필드 구분자로 공백문자를
  사용한다.

```bash
# customer_info.txt 
name    phone-number
====    ============
James   010-5517-0000
Bill    010-0000-8105

# quantity.txt
name    quantity
====    ========
James   5
Bill    3

join customer_info.txt quantity.txt > join_result.txt
```

위와 같은 형태로 진행하면 join된 결과를 얻을 수 있는 것을 확인할 수 있다.

## 텍스트 비교

### comm : 정렬된 두 파일을 행 단위로 비교

* 두 텍스트 파일을 비교하여 각각 유일한 행과 공통된 행들을 표시함
* ex) comm file1.txt file2.txt

### diff : 파일을 행 단위로 비교

* 파일 간의 차이점을 파악할 때 사용
* 프로그램 소스 코드의 버전 간의 차이점을 확인하기 위해 종종 사용
* diff의 일반적인 사용 중 하나는 diff 파일을 만들거나 패치를 
  생성
* 범위 명령 형태의 변경 명령을 출력으로 가짐
  ex) r1ar2 : 두 번째 파일의 r2 위치에 있는 행을 첫 번째 파일의
  r1 위치에 추가

### patch : 원본에 diff 적용하기

* 텍스트 파일에 수정 내용을 적용하기 위해 사용
* diff의 출력 결과를 받아서 이전 버전의 파일을 새 버전으로 
  변환시키는 데 일반적으로 사용

ex)

```bash
diff -Naur file1.txt file2.txt > patchfile.txtt
patch < patchfile.txt
```

## 신속한 편집

### tr : 문자들을 변환 또는 삭제하기

```bash
echo "lowercase letters" | tr a-z A-Z
```

### sed : 텍스트 필터링과 변환용 스트림 편집기

* sed : stream editor의 약자
* 텍스트 스트림과 명시된 파일 집합과 표준 입력에서도 텍스트 편집을 수행
* sed 's/regexp/replacement/' filename

```bash
echo "front" | sed 's/front/back/'
```

vim의 치환 명령과 유사하게 수행된다. s와 같은 치환 명령 말고도 다양한
명령이 있다.
ex) i : 행 앞에 텍스트를 삽입

### aspell : 대화식 맞춤범 검사기

* aspell은 맞춤범 검사기다. 철자 오류 등을 잡아낸다.
* ex) aspell check foo.txt

# Chapter21. 출력 포맷 지정

텍스트 자체의 변경보다 텍스트 출력 포맷을 설정하는 명령어

## 간단한 포맷 툴

간단한 작업이나 파이프라인과 스크립트의 일부로 사용 가능하다.

### nl : 줄 번호 매기기

* ex) nl file1.txt
* 단순히 줄 번호를 매기는 간단한 작업 수행
* cat -n 처럼 사용 가능
* 번호를 붙일 때 논리적 페이지라는 개념 제공
* 줄 번호를 매기는 경우 자주 있지 않지만 보고서를 만드는 등의
  다른 작업과 함께 수행할 때 유용하게 사용 가능하다.

### fold : 지정된 길이로 줄 나누기

* 폴딩(Folding) : 텍스트 행을 지정된 길이로 나누는 절차
* ex) fold -w 12 
* -w 옵션을 주면 한 줄의 너비를 결정할 수 있다.

### fmt : 간단한 텍스트 포메터 

* 텍스트를 자르는 명령어다.
* ex) fmt -cw 50 fmt-info.txt | head
* w 옵션으로 텍스트 너비를 줄 수 있고 c 옵션으로
  들여쓰기를 유지할 수 있다.

### pr : 인쇄용 텍스트 구성하기

* 페이지 매기기를 위해 사용된다.
* ex) pr -l 15 -w 65 distros.txt

### printf : 자료 출력 및 포맷 지정하기

* 형식 : printf " format" arguments
*  ex) printf "I formatted the string : %s\n" foo


# Chapter22. 인쇄

## 인쇄용 파일 준비

### pr : 인쇄용 텍스트 파일로 변환

* 선택적인 페이지 헤더와 여백을 가지고 명시된 페이지 크기에
  맞게 텍스트를 조절하는 데 사용
* ex) ls /usr/bin | pr -3 -w 65 | head

## 인쇄 작업을  프린터로 보내기

### lpr : 파일 인쇄(버클리 스타일)

* 프린터에 파일을 전달할 때 사용
* ex) ls /usr/bin | pr -3 | lpr

### lp : 파일 인쇄(System V 스타일)

* lpr 처럼 인쇄를 위해 파일 또는 표준 입력 받아들임
* ex) ls /usr/bin | pr -4 -w 90 -l 88 | lp -o page-left=36 -o cpi=12 -o lpi=8

## 인쇄 작업 모니터링과 제어

### lpstat : 인쇄 시스템 상태 표시

* 시스템에서 가용한 프린터들의 이름을 확인
* ex) lpstat -a
* -a 은 명시된 printer의 프린터 큐의 상태 표시한다.
* -s 는 인쇄 시스템 상태를 간단히 표시한다.

### lpq : 프린터 큐 상태를 표시

* 큐와 큐가 가지고 있는 인쇄 작업의 상태를 보여주도록 허용
* ex) lpq

### lprm 와 cancel : 인쇄 작업 취소

* 프린트 큐에 존재하는 인쇄 작업을 종료하고 제거하는 기능
* ex) cancel 603
* ex) lpq


# Chapter23. 프로그램 컴파일

소프트웨어를 컴파일해야 하는 이유는?
* 가용성 : 어떤 배포판은 사용자가 원하는 모든 프로그램을 가지고 있지 않을 수 있다.
  -> 이 경우 방법은 소스로부터 그 프로글매을 컴파일하여 만드는 것뿐이다.
* 적시성 : 어떤 배포판은 최신 버전의 프로그램들을 가지고 있는 반면, 그렇지 않은 경우도 많다.
  -> 최신 버전을 갖기 위해서는 컴파일이 필수적이다.

## 컴파일링이란 ? 

* 컴파일링 : 소스 코드 -> 컴퓨터 프로세서의 언어(번역)
* 컴파일러와 함께 자주 사용되는 절차 -> 링킹
  * 프로그램들은 파일 열기와 같은 공통적인 작업들을 많이 수행하는데
  프로그램마다 각각 파일 열기 루틴을 구현한다면 그것은 낭비다.
  -> 파일을 여는 방법이 정의된 프로그램 코드를 필요로 하는 모든 프로그램이
  공유하도록 하는 것이 낫다.
  * 이러한 공통 작업의 지원은 라이브러리를 통해 이루어짐
  * 링커 : 컴파일러의 출력물과 컴파일된 프로그램이 필요한 라이브러리를
  연결하는 데 사용됨

## 모든 프로그램이 컴파일되는가?

* 쉘 스크립트와 같은 프로그램은 컴파일은 필요 없고 직접 실행됨
* 스크립트 언어는 인터프리터라고 불리는 특수한 프로그램에 의해 실행되는데 
  컴파일된 프로그램보다 아주 느리게 실행됨
  -> 컴파일된 프로그램은 한 번만 해석되지만 인터프리트 언어는 매번 번역되고
  실행되기 때문

## C 프로그램 컴파일하기

```bash 
which gcc
```

위 명령어로 gcc라는 c 컴파일러가 이미 설치되어 있다는 것을 알 수 있다.

### 프로그램 빌드하기

* configure 프로그램은 쉘 스크립트이며 빌드 환경을 분석하는 역할을 함
* Makefile은 make 프로그램이 정확히 어떻게 프로그램을 빌드하는지를 알려주는
  설정 파일
* make 명령어로 빌드가 가능함
