# The Linux Command Line Part1 - Learning the Shell


# Introduction에 나오는 인상 깊은 문장들

"Freedom is the power to decide what your computer does, and the only way to have this freedom is to know 
what your computer is doing. Freedom is a computer that is without secrets, one where everything can be known 
if you care enough to find out."

"It's been said that “graphical user interfaces make easy tasks easy, while command line interfaces make difficult 
tasks possible” and this is still very true today."


# Chapter1. What is a Shell?

Shell을 영어사전에 검색하면 조개껍데기, 껍질과 같은 뜻이 나온다. 이는 운영체제의 동작을 통제하는
프로그램인 커널의 외부 형태이기 때문이다. 쉽게 말하면 사용자가 운영체제와 소통하기 위한 인터페이스라고
생각하면 된다. 꼭 Command line의 형태이어야 하는 것은 아니고 Graphical한 형태일 수도 있다. 
커맨드 라인이라면 간단하게 keyboard 입력을 받아서 os가 실행한다고 생각해도 무관하다.

## terminal 형태

User@ComputerName:

@ 앞의 User 자리에 현재 사용자의 이름이 들어가고 ComputerName 자리에 컴퓨터이름이 들어간다. 

## Command history

터미널에서 윗쪽 화살표 키를 입력하면 기존에 입력했던 명령어들을 확인할 수 있다. 계속 눌러보면
기존에 입력했던 명령어들이 하나씩 보이는 것을 볼 수 있다. 그리고 다시 아래쪽 화살표를 누르면
입력했던 명령어 다음에 입력했던 명령어를 볼 수 있다. Command history 즉 명령어 이력을 확인할 
수 있다.

## 간단한 명령어들

date : 현재 날짜와 시간을 출력한다.
cal : 달력 형태로 날짜와 시간을 보여준다.
df : 디스크의 빈 공간을 확인할 수 있다.
free : 메모리의 빈 공간을 확인할 수 있다.
exit : 종료

df, free와 같은 명령어들에서 굉장히 편하게 현재 컴퓨터의 정보를 파악할 수 있다는 것을 느낄 수 있다.

## 가상 콘솔


# Chapter2. Navigation

리눅스에서는 어떻게 파일 시스템을 옮겨 다닐 수 있을까?

중요한 명령어는 pwd, cd, ls이다.
* pwd(print working directory)
* cd(change directory)
* ls(list directory contents)

어떤 말의 약어인지 파악하면 감이 온다.

리눅스의 파일 시스템은 트리의 형태를 띄고 있다. 윈도우와 다르게 하나의 트리, 하나의 계층적 구조를 가진다.
저장장치와 상관이 없다. 저장장치는 관리자의 의도에 따라 붙였다(mount) 떼어냈다가 할 수 있을 뿐이다.

처음 리눅스 파일 시스템을 익히는 입장에서는 트리 형태의 미로라고 생각하면 된다. 트리의 어디쯤 위치하고
있는지 알고 싶을 때 사용하는 명령어가 pwd다. 즉 현재 위치하고 있는 디렉토리를 확인할 수 있다.

pwd(print working directory)

cf) 처음 log in을 하면 home directory에서 시작한다. 각 계정마다 home directory가 있고 그 디렉토리가
그 User가 쓰기 작업을 할 수 있는 유일한 공간이다.

어떤 가지가 붙어있고 어디로 갈 수 있는지 확인하는 명령어가 ls이다. 어떤 디렉토리와 연결되어 있는지
확인할 수 있다.

ls(list directory contents)

그리고 실제로 옮겨가는 명령어가 cd다. 

cd(change directory)

cd (pathname)

pathname 자리에 옮겨갈 경로의 이름을 넣어주면 된다. 

이 때 경로의 이름을 적어주는 2가지 방법이 있는데 바로 절대경로와 상대경로다.

두 경로의 차이는 기준이 무엇인가 하는 것이다. 

먼저, 절대경로는 root directory를 기준으로 한다. root directory는 트리의 가장 상단에 위치하는
디렉토리를 말한다. 그래서 절대경로를 사용해서 디렉토리를 옮기려면 root directory에서부터 옮기려는
디렉토리명이나 파일명까지 입력해주면 된다.

```bash
cd /usr/bin
```

위의 /usr/bin에 가장 앞에 오는 / (슬래시 기호)는 root directory를 뜻한다. 그래서 root 디렉토리 하위의
 usr 디렉토리 하위의 bin 디렉토리로 이동하겠다는 뜻이다.

두번째, 상대경로는 기준이 현재 작업하고 있는 디렉토리가 된다. 

```bash
cd .
cd .. 
```

.(점/dot)은 현재 작업하고 있는 디렉토리를 말한다. 
..(점점/dotdot)은 현재 작업하고 있는 디렉토리의 바로 상위 디렉토리를 말한다.
그래서 위 명령어는 현재 디렉토리라는 명령어 그리고 상위 디렉토리로 이동하라는
뜻이 된다.

```bash
cd ./bin
cd bin
```

그리고 위 명령어에서 cd ./bin 즉 현재 디렉토리의 하위 디렉토리인 bin 디렉토리로 이동하라는 명령어는
./ 을 생략하고 사용하는 것이 가능하다.

cf) 도움이 되는 단축키들

```bash
cd ~ 
cd -
cd ~user_name
```
위 명령어는 위에서부터 
cd ~ : home directory로 이동하라
cd - : 이전에 작업하던 디렉토리로 이동하라
cd ~user_name : user_name에 해당하는 사용자의 home directory로 이동하라

cf) 리눅스 파일 시스템에서의 주의사항
* 파일명에 .(점/dot)이 붙는 경우 숨김 파일이다. 즉 ls 명령어를 입력해도 안 보인다.
  ls -a를 입력하면 된다.
* 리눅스는 대소문자를 구분한다.
* Linux는 파일 확장자 개념이 없다!
  어떻게 이름을 지어도 상관 없지만 응용프로그램의 경우 대개 확장자명을 붙인다.
* 파일명에 스페이스를 넣지 말도록 한다. 나중에 후회한다. _(underscore)를 사용하도록 한다.
  리눅스 파일시스템에서 따로 막지는 않지만 사용하지 않는 것이 좋다. 확인해보니 공백 이전까지만
  파일명을 인식한다. ex) test space -> test


# Chapter3. Exploring The System

## ls 더욱 살펴보기

아래는 시스템을 탐색하는 데 도움이 되는 세 가지 명령어다.
* ls(List directory contents)
* file(Determine file type)
* less(View file contents)

그냥 ls만 입력해서 사용하는 것도 가능하지만 다음과 같이 사용하는 것도 가능하다.
ls (pathname)

```bash
ls /usr
```
위와 같이 입력하면 /usr 디렉토리의 하위 내용을 출력할 수 있다.

```bash
ls ~ /usr
ls ~/ready ~/ready/dudaji/usr
```
와 같이 두 개 이상의 디렉토리에 대해서도 가능하다.

또 상세히 하위 내용을 출력하는 것도 가능하다. 다음과 같이 입력하면 된다.

```bash
ls -l
```

위 명령어를 살펴보면 하나 또는 그 이상의 옵션과 인자를 줄 수 있다.
대부분은 아래와 같은 형식이다.

command -options arguments

옵션을 여러 개 주는 것도 가능한데 다음과 같이 작성하는 것도 가능하다.

```bash
ls -lt
```

위 lt에서 l은 상세히 출력하는 long format option이고, t는 파일의 수정시간 순으로
정렬하여 출력하는 옵션이다.
(확인해보니 나중에 수정한 것이 위에 온다.)

```bash
ls -lt --reverse
```

위의 명령어에서 --reverse 옵션을 주면 순서가 뒤집힌다.

ls 명령어의 옵션은 --reverse와 같이 long option을 주거나 -r로 축약해서 주는 것 
모두 가능하다.

그러므로 다음과 같이 표현하는 것도 가능하다.

```bash
ls -ltr
```

ls -l로 상세히 특정 디렉토리의 하위 내용을 출력했을 때 그 내용을 제대로 살펴보는 것도
시스템을 탐색하는데 도움이 된다.

맨 왼쪽에는 다음과 같은 기호가 있다.

-rw-r--r--

총 10개의 문자인데 /(슬래시)를 기준으로 나누어서 파악할 수 있다.

\- / rw- / r-- / r-- 

맨 처음에 오는 -(dash)는 내용의 type을 말한다. 이 경우 - (dash)가 적혀있는 경우
파일이라는 뜻이다. d는 디렉토리를 말하고 이 두 가지 말고도 다른 type이 될 수 있다.

\- / rw- / r-- / r-- 

타입 / 파일 소유자의 권한 / 그룹 멤버의 권한 / 모든 사용자의 권한

2번째 칸의 rw-는 파일 소유자의 권한을 말한다.
이 경우 r(read), w(write)의 접근 권한을 가지고 있는 것이다.

이 10개의 문자 다음으로 오는 1은 하드 링크들의 파일 번호(File's number of hard links)
를 말한다.

그 다음 차례대로 다음과 같이 연결된다.

root / root / 32059 / 2007-04-03 11:05 / oo-cd-cover.pdf

소유자 / 그룹명 / 파일사이즈 / 수정날짜 / 파일명

## Determining A File Type with file 

시스템을 탐색하면서 수많은 파일을 보게 되는데 파일의 내용이 어떤 내용인지 알 수 있다면 
좋을 것이다. 이때 사용하는 것이 file 명령어다. 앞서 살펴봤듯이 리눅스에서는 파일명이 
파일 내용을 반영하지 않는다. 확장자 개념이 없다. 그러므로 file 명령어를 사용하면 해당
파일에 대한 간단한 내용을 파악할 수 있다.

```bash
file scheduler.py
```

사실 파일의 종류는 다양하고 리눅스와 같은 유닉스 계열의 운영체제는 "Everything is a file"
(모든 게 파일이다.)이다.

## Viewing File Contents with less

less는 텍스트 파일을 확인할 때 사용하는 명령어다. 파일의 종류는 다양하고 그 중 많은 텍스트 파일이
있다. less 명령어는 이런 텍스트 파일을 확인할 때 유용하게 사용할 수 있다.

텍스트 파일을 확인하는 것이 중요한 이유는 다양한 시스템 설정 파일 그리고 시스템이 실행하는 스크립트 
파일이 텍스트 형태로 되어 있기 때문이다. 이런 텍스트 파일을 잘 이해하는 것은 시스템이 어떻게 동작하는지
파악하는데 큰 도움이 된다.

```bash
less scheduler.py
```

## Linux File System

리눅스 파일 시스템은 대부분의 유닉스 계열 운영체제의 파일 시스템과 유사하다. 모든 리눅스 운영체제가
Linux Filesystem Hierarchy Standard를 따르고 있는 것은 아니지만 대부분은 따르고 있다.

루트 디렉토리에서 시작해서 각각의 디렉토리가 어떤 내용을 담고 있는지 살펴보면 파일 시스템의 구조를 
살펴보는데 큰 도움이 된다.

## Symbolic Link

ls -l 명령어로 정보를 살펴봤을 때 type이 l이고 파일명이 화살표로 다른 파일명을 가리키고 있는 형태를
종종 볼 수 있다. 이런 종류의 파일을 Symbolic Link라고 한다. 리눅스에서는 하나의 파일이 다양한 이름에
의해 참조될 수 있다. 굉장히 유용한 기능이다.

예를 들어 하나의 파일을 공유하고 있고 그 파일이 변경이 잦다고 한다면 문제가 생길 수 있다. 예를 들어 그 
파일을 참조하는 다양한 프로그램은 그 파일의 파일명이 변경될 때마다 프로그램 내에서의 이름을 바꾸어주어야
한다. 그런 불상사를 막기 위해 심볼릭 링크라는 형태의 파일이 생긴 것이다. 말그대로 링크 파일 즉 연결된 파일을
생성하는 셈이다. 그 링크 파일을 열면 사실상 그 파일과 연결된 원래 파일이 참조된다. 이렇게 되면 변화를 수용하기
쉽다. 포인터만 바꾸어주면 되는 셈이다.


# Chapter4. Manipulating files and directories

아래는 파일 시스템 내의 파일과 디렉토리를 다룰 수 있는 명령어다.
* cp : 파일과 디렉토리를 복사한다.
* mv : 파일과 디렉토리를 이동시키거나 이름을 변경한다.
* mkdir : 디렉토리를 생성한다.
* rm : 파일과 디렉토리를 삭제한다.
* ln : 하드 링크와 심볼릭 링크를 생성한다.

그래픽 유저 인터페이스에서 처리하는 것이 더 쉽지 않은가라고 생각할 수도 
있지만 한 디렉토리 내 모든 html 파일을 다른 폴더로 옮기거나 특정 조건의
파일만 다른 디렉토리만 옮기는 등의 작업은 그래픽 유저 인터페이스에서 처리하는
것이 쉽지 않다.

## 와일드카드

빈번하게 사용하는 위 5개 명령어를 익히기 전에 알아두면 좋은 것, 날개를 달아주는
것이 와일드카드다.

와일드카드를 이용해서 특정 파일명의 파일을 한꺼번에 선택하는 것이 가능하다.

\* : 일치하는 모든 문자열
? : 일치하는 하나의 문자
[characters] : [] 안에 있는 문자 집합의 원소에 일치하는 것
[!characters] : [] 안에 있는 문자 집합의 원소에 일치하지 않는 것
[[:class:]] : 특정 클래스의 집합에 일치하는 문자
  * [:alnum:] : 영문과 숫자
  * [:alpha:] : 영문
  * [:digit:] : 숫자
  * [:lower:] : 소문자
  * [:upper:] : 대문자

  와일드카드를 사용한 예)
  * \* : 모든 파일
  * g* : g로 시작하는 모든 파일
  * b*.txt : b로 시작하는 텍스트 파일
  * [abc] : a 또는 b 또는 c로 시작하는 모든 파일
  * Backup\[0-9\]\[0-9\]\[0-9\] : Backup.뒤에 0부터 9까지의 숫자 중 하나가 세 개 있는 문자

파일명을 인자로 받는 모든 명령에 적용 가능하기 때문에 굉장히 강력하다고 할 수 있다.

## mkdir

와일드카드를 알아본 다음 가장 먼저 알아볼 명령어는 mkdir이다.

```bash
mkdir dir1
mkdir dir1 dir2 dir3
```

디렉토리를 생성하는 명령어이고 위의 명령어처럼 한꺼번에 여러 디렉토리를 생성하는 것도 가능하다.

## cp

복사하는 명령인 cp는 두 가지 방법이 있다. 하나는 

```bash
cp item1 item2
```

하나의 디렉토리 또는 파일을 다른 디렉토리 또는 파일로 복사하는 방법이다.

두 번째 방법은 여러 개의 파일이나 디렉토리를 하나의 디렉토리로 복사하는 방법이다.

```bash
cp item1 item2 ... directory
```

cp에는 옵션이 다양하다. 여기서 나오는 옵션들은 뒤에서도 공통적으로 나오는 옵션들이 많다.
* -a(--archive) : 권한을 포함한 모든 것이 복사된다.
* -i(--interactive) : 덮어쓰기 전에 사용자에게 확인을 받는다. 옵션을 안 주면 그냥 덮어쓴다.
* -r(--recursive) : 재귀적으로 디렉토리와 파일을 복사한다. 디렉토리 자체는 디렉토리 안에 
또 다시 디렉토리가 있는 재귀적인 구조이기 때문에 디렉토리를 복사하기 위해서는 이 recursive
옵션을 설정해주어야 한다.
* -u(--update) : 복사하려는 디렉토리에 파일이 없거나 변경이 있는 파일만을 복사한다.
* -v(--verbose) : verbose를 영어사전에 검색하면 '장황한'과 같은 뜻이 나온다. 복사를 진행할 때
진행하는 작업에 대한 내용을 텍스트로 보여준다.

cp 작업의 예)
* cp file1 file2
* cp -i file1 file2
* cp file1 file2
* cp file1 file2 dir1
* cp dir1/* dir2
* cp -r dir1 dir2

## mv 

cp와 마찬가지다. 두 가지 방법이 있다.

파일 이름 또는 디렉토리명을 변경하거나 디렉토리나 파일을 이동시킬 때 사용 가능하다.

```bash
mv item1 item2
```

하나 이상의 디렉토리나 파일을 다른 디렉토리로 이동시킬 때 사용하는 것도 가능하다.

```bash
mv item1 item2 ... directory
```

cp와 마찬가지로 옵션을 주는 것이 가능하다.

# rm 

```bash
rm item ...
```

하나 또는 하나 이상의 디렉토리나 파일을 삭제하는데 사용한다.

rm 역시도 옵션을 공유한다. 특히 삭제할 때 디렉토리의 경우

-r(--recursive) 옵션을 주어야 삭제가 가능하다. cp와 같은 이유다.

그리고 앞에서 보지 못한 

-f(--force) 옵션이 있는데 이는 존재하지 않는 파일을 지우려고 해도 무시하고
계속 다른 작업을 진행하라는 말이다. -i(--interactive) 옵션을 줘도 -f 옵션을
주면 그냥 무시하고 진행한다. -i 옵션을 덮어쓴다고 생각하면 된다.

그리고 rm 명령어를 사용할 때는 특히 주의해야 한다. 윈도우처럼 휴지통에 갔다가 지워지는 것이
아니라 그냥 끝이다. 못 되돌린다. 신중하게 그리고 주의해서 사용하도록 해야 한다.

## ln 

하드 링크나 심볼릭 링크를 생성하는 명령어다.

```bash
ln file link
```

위는 하드 링크를 생성하는 명령어다. 그리고 아래는 심볼릭 링크를 생성하는 명령어다.

```bash
ln -s item link
```

item은 파일일 수도 있고 디렉토리일 수도 있다.

## 하드 링크(Hard Link)

모든 파일은 기본적으로 하나의 하드 링크를 가진다. 그런데 하드 링크를 하나 더 만들어주면
파일을 가르키는 화살표가 하나 더 생기는 셈이다.

->(1) file (2)<-  

원래 파일을 가르키는 (1)번 화살표만 있었는데 (2)번 화살표를 생성해서 접근할 수 있는 수단을
하나 더 만들어주는 셈이다. 복사본이 하나 더 생기는 셈이 아니라 실제 파일을 가르키는 화살표가
하나 더 생기는 셈이기 때문에 1번 화살표와 2번 화살표는 동등하다.

하드 링크의 문제점은 파일 시스템 외부에서는 참조할 수 없다는 것이다. 즉 디스크 내의 같은 파티션이
아니면 참조할 수 없다.

그리고 하드 링크는 디렉토리를 참조하지 않을 수 있다. 하드 링크가 만약 지워지면 그 파일을 가리키는 
하드 링크가 존재하는 한 남아있는다. 파일을 가르키는 모든 하드 링크가 삭제되면 그때 사라진다.

## 심볼릭 링크(Symbolic link)

심볼릭 링크는 하드 링크의 문제점을 보완하기 위해 생겼다. 심볼릭 링크가 생성되면 심볼릭 링크는 
참조할 파일이나 디렉토리를 가르키는 텍스트 포인터가 담기는 파일을 생성한다. 윈도우의 바로가기
아이콘처럼 생각하면 된다. 사실 리눅스에 더 먼저 있었던 셈이다.

윈도우에서 바로가기 아이콘을 열어서 해당 파일를 수정하면 그 파일의 내용은 수정된다. 하지만 그
바로가기 아이콘을 지운다고 그 파일 자체가 지워지는 것은 아니다.

그림으로 생각해보면

file <-(1) text pointer file <-(2)

이런 식이 되는 것이다. 2번 화살표를 통해 접근하면 포인터를 통해 실제 파일에 접근할 수 있다.
하지만 2번 화살표가 지워진다고 실제 파일이 사라지는 것은 아니다. 그냥 가리키고 있던 화살표가
하나 지워지는 셈이다.

하드 링크와 심볼릭 링크의 차이점
출처 : http://junsik.tistory.com/34


# Chapter5. Working with commands

무언가를 실행하는 명령에 익숙하지만 명령 자체에 대한 명령도 있다.

명령어를 계속 사용해왔는데 명령어가 정확히 뭘까?

네 가지 정도로 생각해볼 수 있다.
* 실행 가능한 프로그램 ex) c++로 작성된 프로그램
* shell 자체에 내장된 명령어
* shell 스크립트 함수
* alias(다른 명령어에 대해 다른 이름으로 tag를 붙여둔 명령어)

명령어에 대한 명령어를 나누면 크게 세 가지다.
* 명령어에 대해 알아보는 명령어 
* 명령어에 대한 문서를 확인하는 명령어
* 사용자가 정의하는 명령어

## 명령어에 대해 알아보는 명령어

1) type : 어떤 종류의 명령이 실행될지 살펴보는 명령어

```bash
type ls
```

2) which : 시스템 내 설치된 어떤 명령이 실행될지 확인하는 명령어

```bash
which python
which python3
```

## 명령어에 대한 문서를 확인하는 명령어

1) help (명령어) : 명령어를 어떻게 사용하는지 용법을 보여준다.

```bash
help cd
```

```bash
mkdir --help
```

2) man (명령어) : 해당 명령어 즉 프로그램에 대한 매뉴얼을 보여준다.

```bash
man ls
```

man 명령어를 사용하면서 참고할 부분은 매뉴얼에 레이아웃이 있어 섹션이
나누어져 있다는 것이다. 아래와 같이 1번은 User commands고 2번은
Programming interfaces for kernel system calls이다.

1 User commands
2 Programming interfaces for kernel system calls
3 Programming interfaces to the C library
4 Special files such as device nodes and drivers
5 File formats
6 Games and amusements such as screen savers
7 Miscellaneous
8 System administration commands

그런데 man 명령을 하면서 섹션을 명시해주지 않으면 항상 가장 처음 일치하는
명령을 반환하기 때문에 계속 1번 섹션의 명령어만 참조되는 불상사가 생길 수 있다.

man section search_term

위와 같은 형식으로 명령을 내려주면 된다. 예를 들면 다음과 같다.

```bash
man 5 passwd
```

3) apropos : man에서 특정 검색어와 일치하는 관련 명령어를 반환하는 명령어

```bash
apropos floppy
```

4) whatis : 그 명령어의 정보를 한 줄 설명으로 보여주는 명령어

```bash
whatis ls
```

5) info : 리눅스에서는 man 명령어로 볼 수 있는 매뉴얼 말고도 info 명령어로 
정보를 볼 수 있다. 각각의 문서는 하나의 주제로 되어 있고 하이퍼링크로 연결되어
있다.

```bash
info coreutils
```

## 사용자가 정의하는 명령어

alias를 통해 원하는 명령어를 정의할 수 있다. 

예를 들어 다음과 같이 명령어를 한꺼번에 3개를 실행한다고 생각해보자.

```bash
cd /usr; ls; cd -;
```

그리고 이러한 명령어를 빈번하게 사용해야한다고 생각해보자. 그러면 alias로 
세 연속된 명령어에 대해 새로운 별칭을 줘서 간결하게 실행하는 것이 가능하다.

대신 alias를 적용하기 전에 먼저 그 명령어의 이름이 정의되어 있는 것은 아닌지
확인해보는 것이 필요하다.

type 명령어로 확인해보면 된다. 예를 들어 test 명령어의 경우 이미 정의가 되어
있다. 그러니 예를 들어 foo라는 이름을 type으로 먼저 확인해보고 그 이름을
이용해서 정의해주면 된다.

```bash
alias foo='cd /usr; ls; cd -;'
```

alias (새로 정의할 이름) (명령어 문자열)

형식으로 정의하면 된다. 그 다음부터는 새로 정의한 이름만 입력해도 명령어가 실행된다.
이 경우 foo만 입력해도 명령이 실행된다. alias를 해제하려면 다음과 같이 해제해주면 된다.

```bash
unalias foo
```

그리고 type 명령어로 제대로 해제가 되었는지 확인하는 것도 가능하다.

참고로 alias만 입력하면 설정된 alias를 확인할 수 있다.


# Chapter6. Redirection

Redirection, 방향을 바꾸어 준다는 말이다. 무엇의 방향을 바꾸어준다는 말일까?
Redirection을 이해하려면 먼저 standard input, standard output, standard error
를 이해해야 한다. 

우리가 프로그램을 실행하면 그 결과는 크게 두 가지가 첫 번째는 실제 그 프로그램이 
실행되어서 출력하는 값 또는 결과다. 두 번째는 상태나 에러다. 프로그램이나 명령어가 
인자가 없다거나 찾을 수 없다거나 하는 이유로 에러를 출력하고 멈출 수 있다.

리눅스는 앞서 살펴봤듯이 모든 게 파일이다. 예를 들어 ls 명령을 실행하면 
그 결과는 standard output이라는 파일로 간다. 그리고 그 상태 메세지는 
standard error라는 파일로 보내지게 된다. 두 파일은 디스크에 쓰여지지 않고
화면에 출력된다. 그래서 우리가 결과값을 볼 수 있는 것이다.

우리는 대개 프로그램의 입력을 keyboard로 받는다. 이를 standard input이라고
하는데 키보드와 연결되어 있다고 보면 된다. 

redirection은 I/O redirection을 말하는데 즉 입력과 출력의 방향을 바꾸어 줄 수 
있다는 것이다. 예를 들어 대개 키보드로 입력을 받아서 화면으로 출력하는데 이를 
화면에 출력하지 않고 다른 파일에 출력해서 쓰는 것이다.

그런데 왜 이런 개념이 필요할까? 종종 명령어의 결과를 저장해두면 유용한 상황이 있기
때문이다.

예를 들어 다음과 같은 명령어를 실행하면 화면에 결과가 출력되지 않고 ls-output.txt
라는 파일에 내용이 써진다.

```bash
ls -l /usr/bin > ls-output.txt
```

여기서 사용된 '>'는 redirection 연산자라고 한다. 이 연산자를 통해 redirection을 
실행할 수 있다.

그렇다면 명령어 없이 > ls-output.txt를 입력하면 어떻게 될까? 새로운 빈 파일이 
생성된다.

```bash
> ls-output.txt
```

그렇다면 안 덮어쓰고 덧붙여 쓰려면 어떻게 해야 할까?

```bash
ls -l /usr/bin >> ls-output.txt
```

위와 같은 명령어로 덧붙여 쓰는 것이 가능하다. 기존 파일이 없으면 그냥 > 를 사용해서
생성한다.

## stderr에 redirect하려면?

만약 위와 같이 존재하지 않는 디렉토리에 대해 ls 명령어를 적용한다면? 

```bash
ls -l /bin/usr > ls-output.txt
```

오류다. 스크린에 오류가 출력된다. 그럼 왜 > 연산자를 사용해도 바로 스크린에 
출력되는 것일까? redirection을 적용했으니 텍스트에 담겨야 할 것이다.

이유는 ls 명령어가 오류는 standard output으로 보내지 않기 때문이다.
대신 stderr 즉 standard error로 보낸다. 그렇다면 stderr는 어떻게 
redirect할까? 

stderr를 redirect하는 것은 > 연산자로 부족하다. file discriptor를 활용해야
한다. 

프로그램은 파일 스트림에 출력을 만드는데 시스템에서 첫 번째 스트림 3개를
0 : standard input
1 : standard output
2 : standard error
이렇게 참조한다. 그러니 standard error의 번호인 2번으로 standard error을 
참조한다. 아래와 같이 redirect해주면 된다.

```bash
ls -l /bin/usr 2> ls-error.txt
```

참고) 
파일 디스크립터
http://dev-ahn.tistory.com/96

파일 디스크립터
출처 : http://mintnlatte.tistory.com/266

## stdout과 stderr를 함께 담으려면?

그리고 만약 stdout과 stderr를 한 파일을 담고 싶다면 아래와 같이 처리하면
된다.

```bash
ls -l /bin/usr > ls-output.txt 2>&1
```

순서가 중요하다. 아래와 같이 하면 에러가 난다.

```bash
2>&1 > ls-output.txt 
```

그리고 최근에는 아래와 같이 redirect해준다.

```bash
ls -l /bin/usr &> ls-output.txt
```

## 원하지 않는 출력을 처리하려면?

리다이렉트하면서 원하지 않는 출력을 처리하려면 어떻게 하면 될까?
특히 에러나 상태 메시지 말이다. 이땐 아래와 같이 dev 디렉토리 밑에
/dev/null 이라는 파일이 있는데 이 파일은 input을 받아서 아무 것도 하지
않는다. (이 파일을 bit bucket이라고 하기도 한다.)

```bash
ls -l /bin/usr 2> /dev/null
```

## standard input을 redirect하려면?

그렇다면 standard input을 redirect하려면 어떻게 해야 할까?

### cat 명령어

cat 명령어는 하나 이상의 파일을 읽어서 standard input에 복사하는 명령어다.
하나 이상 즉 여러 개의 파일을 arguments로 받을 수 있기 때문에 파일을 합치는 데에도
사용된다. 만약 멀티미디어 파일처럼 너무 큰 파일이여서 쪼개서 파일을 받았다면 아래와
같이 합쳐주면 된다.

```bash
cat movie.mpeg.0* > movie.mpeg
```

그렇다면 인자 없이 cat을 입력했다면 어떻게 될까?

```bash
cat
```

인자를 주지 않으면 입력을 기다린다. default는 stdin이기 때문이다. 
(Ctrl + d로 종료가 가능하다. EOF라고 알려주는 셈이다.) 

아래와 같이 입력하면 간단하게 텍스트 파일도 만들어낼 수 있다.

```bash
cat > test.txt
```

### Pipelines 명령어

standard input을 받아서 redirect하는 방법으로는 pipelines도 있다.
pipelines는 standard input을 받아서 standard output으로 redirect
하는 방법이다. 연산자로는 '|'을 사용한다.

command1 | command2

```bash
ls -l /usr/bin | less
``` 

위와 같이 활용할 수 있다. 그렇다면 >와 |는 무슨 차이일까? redirect 연산은
command1 > file1
즉 command의 결과를 file에 연결시키는 연산이었다.
반면, pipeline 연산자는 한 명령의 결과를 다른 명령어의 입력으로 연결시킨다.
command1 | command2
와 같은 구조가 되는 것이다.

주의해야 할 것이 만약 
cd /usr/bin
ls > less
하면 linux의 less 파일을 덮어쓰기 때문에 박살난다.

### Filters

pipelines는 데이터에 대한 복잡한 연산을 할 때 종종 사용된다.
그래서 여러 개의 명령 파이프라인에 사용 가능하다.
이런 방식을 Filter라고 한다. 예는 다음과 같다.

```bash
ls /bin /usr/bin | sort | less
```

### uniq

uniq 연산은 sort와 같이 주로 사용되는데 결과에서 duplicate(중복)을
제거해준다.(default)

예를 들면

```bash
ls /bin /usr/bin | sort | uniq | less
```

이렇게 쓰일 수 있다.
만약 중복을 보고 싶다면 

```bash
ls /bin /usr/bin | sort | uniq -d | less
```
이렇게 사용하면 된다.

### wc(word count)

라인, 단어, 바이트 수를 출력한다.

```bash
ls /bin /usr/bin | sort | uniq -d | wc -l
```

위와 같이 작성하면 라인만 출력한다.

### grep

grep은 파일에서 텍스트의 패턴을 찾을 때 사용한다.

grep pattern [file...]
(여기서 pattern은 정규 표현식 패턴도 가능하다.)

예를 들어 zip이라는 단어를 찾고 싶을 때

```bash
ls /bin /usr/bin | sort | uniq -d | wc -l
```


# Chapter7. Seeing The World As The Shell Sees It 

## Expansion(확장)

우리가 명령어를 입력하고 엔터를 치면 bash에서는 우리에게는 보이지 않지만 
몇 가지 과정을 거친다.

예를 들어 echo는 텍스트를 출력하는 명령어인데 다음과 같이 명령하면 
결과는 예상대로다.

```bash
echo this is a test
```
output : this is a test

하지만 다음과 같이 와일드카드를 사용해서 명령어를 입력하면 Asterisk(*)가 
출력되지 않고 현재 디렉토리의 파일과 디렉토리를 출력했다.

```bash
echo *
```
output : Desktop Documents ls-output.txt Music Pictures Public Templates
Videos

그 이유는 shell 안에서는 결과를 출력하기 전에 Asterisk(*)과 같은 와일드카드 등의 
값들에 대해 그 의미에 맞게 가공하기 때문이다.

이를 Expansion(확장)이라고 한다.

```bash
echo *
echo D*
echo *S
echo /usr/*/share
```

위와 같이 명령을 내리면 그 의미에 맞게 결과를 확장해서 출력하는 것이다. 

참고) echo * 를 했을 때 hidden file(숨긴 파일)은 어떻게 처리될까?
숨긴 파일의 경우 말그대로 숨긴 파일이기 때문에 그 의미를 존중해 출력하지
않는다. 하지만 방법은 있다.

간단하게는 echo .* 라고 입력하면 된다.
하지만 이 경우 . (현재 디렉토리), .. (바로 상위의 디렉토리) 까지 함께 출력된다,
그러므로 다음과 같이 처리하면 된다.

```bash
echo *
ls -d .* | less
echo .[!.]*
ls -A
```

Expansion을 거치는 것은 와일드카드만이 아니다.
* Tilde(~) : 앞서 살펴본 것처럼 ~(User) 라고 입력했을 경우 해당 사용자의 홈 디렉토리를 의미한다.
* 산술 연산 : echo $((expression)) 이라고 입력하면 expression이 확장된 결과를 확인할 수 있다.

```bash
echo \$\(\(2+2\)\)
```

* Brace expansion(중괄호) : {} 안에 문자열의 리스트 또는 수의 범위를 입력해주어서 결과를 출력할 수 있다.

```bash
echo Front-{A,B,C}-Back
```
output : Front-A-Back Front-B-Back Front-C-Back

```bash
echo {001..15}
```
output : 001 002 003 004 005 006 007 008 009 010 011 012 013 014 015

Brace expression을 활용하는 흔한 방법 중 하나는 디렉토리를 생성할 때 사용하는 것이다.

```bash
mkdir {2007..2009}-{01..12}
ls
```
output : 
2007-01 2007-07 2008-01 2008-07 2009-01 2009-07
2007-02 2007-08 2008-02 2008-08 2009-02 2009-08
2007-03 2007-09 2008-03 2008-09 2009-03 2009-09
2007-04 2007-10 2008-04 2008-10 2009-04 2009-10
2007-05 2007-11 2008-05 2008-11 2009-05 2009-11
2007-06 2007-12 2008-06 2008-12 2009-06 2009-12

굉장히 강력하기 때문에 유용하게 사용할 수 있다.

* Parameter expansion(매개변수 확장) : 시스템에서는 특정 데이터에 대해 이름을 붙여놓았는데 그 시스템 변수에
대해서도 확장이 가능하다. 셀 스크립트를 작성할 때 유용하게 사용 가능하다.

```bash
echo \$USER
```
output : chaehwan

* Command Substition (명령어 대체) : 명령어에 대해서도 확장은 가능하다. 

```bash
echo \$(ls)
```
output : Desktop Documents ls-output.txt Music Pictures Public Templates
Videos

## Quoting(따옴표 붙이기) : 원하지 않는 expansion을 막기 위해 사용한다.
  
* 첫번째 방법은 큰따옴표로 감싸는 방법이다. 큰따옴표로 감싸면 그 안의 내용은
특수한 의미를 잃어버리고 일반적인 문자처럼 취급된다.
하지만 예외도 있다. "$", "\(backslash)", "`(back-quote)"는 예외다. 즉 
매개변수 확장, 산술 연산 확장, 명령어 대체는 예외가 되는 셈이다.
* 참고로 ""(큰따옴표)를 붙이면 파일 사이에 공백이 있는 경우 문제가 해결된다.
ls -l two words.txt는 안되지만 ls -l "two_words.txt"는 된다.
* 두번째 방법은 작은따옴표로 감싸는 방법이다. 작은따옴표를 사용하면 모든
확장을 막을 수 있다.

```bash
$ echo text ~/*.txt {a,b} \$(echo foo) \$((2+2)) $USER
```
output : text /home/me/ls-output.txt a b foo 4 me

```bash
$ echo \"text ~/*.txt {a,b} \$(echo foo) \$((2+2)) $USER\"
```
output : text ~/*.txt {a,b} foo 4 me

```bash
$ echo \'text ~/*.txt {a,b} \$(echo foo) \$((2+2)) $USER\'
```
output : text ~/*.txt {a,b} $(echo foo) $((2+2)) $USER

## Escaping characters(이스케이핑)

"$", "!", "&", " " 와 같은 다른 의미를 가지는 문자는 \\(backslash)를
붙임으로써 다른 특별한 의미가 그 자체로 출력될 수 있다. ''을 Quoting이 
아니라 정말로 인용구를 감싸는 의도로 사용하고 싶다면 \\(backslash)를 사용하면
되는 것이다.


# Chapter8. Advanced Keyboard Tricks

Linux terminal에서는 최대한 마우스를 사용하지 않고 작업하는 것이 가능하다.

## Command Line editing

1) Cursor movement

가장 먼저 커서를 키보드를 사용해서 이동하는 방법이다.

Ctrl + a : 커서를 라인의 가장 앞으로 이동시킨다.
Ctrl + e : 커서를 라인의 가장 뒤로 이동시킨다.
Ctrl + f : 커서를 문자 하나만큼 앞으로 이동시킨다.(->)
Ctrl + b : 커서를 문자 하나만큼 뒤으로 이동시킨다.(<-)
Alt + f : 커서를 단어 하나만큼 앞으로 이동시킨다.
Alt + b : 커서를 단어 하나만큼 뒤로 이동시킨다.
Ctrl + l : clear 명령과 같다. 화면을 깨끗하게 만든다.

2) Modifying Text

다음은 텍스트를 수정하는 방법이다.

Ctrl + d : 커서 위치에서 문자 하나 지운다.
Ctrl + t : 커서 위치에서 하나 앞의 위치의 문자와 위치를 바꾼다.
Alt + t : 커서 위치에서 하나 앞의 단어와 위치를 바꾼다.
Alt + l : 커서 위치부터 끝까지 모든 문자를 소문자로 바꾼다.
Alt + u : 커서 위치부터 끝까지 모든 문자를 대문자로 바꾼다.

3) Cutting and Pasting Text

Ctrl + k : 커서 위치에서부터 라인의 끝까지 텍스트를 지운다. 
Ctrl + u : 커서 위치에서부터 라인의 처음까지 텍스트를 지운다.(Ctrl + k와 반대)
Alt + d : 커서 위치에서부터 현재 단어의 끝까지 텍스트를 지운다.
Alt + Backspace : 커서 위치부터 현재 단어의 시작까지 지운다.
(현재 커서가 단어의 시작이면 이전 단어를 지운다.)
Ctrl + y : kill당해 버퍼에 있는 텍스트를 가지고 와서 커서 위치에 삽입한다.

참고) The Meta Key

과거에는 꼭 그런 것은 아니었지만 Alt 키가 현대의 메타 키라고 볼 수 있다.

## Completion

명령어를 타이핑하면서 Tab 키를 누르면 자동완성이 되는 것을 확인할 수 있다.
경로명을 완성하는데 가장 빈번하게 사용된다. 시스템 변수, 명령어 등 다양한 
곳에서 사용된다.

Tab 키 말고도 자동완성과 관련된 명령어가 있다.

Alt + ? : 가능한 자동완성 목록을 모두 보여준다.
(Tab 키를 두 번 눌러도 같은 효과가 난다.)
Alt + * : 가능한 자동완성 목록을 삽입한다. 

## Using History

terminal에서 방향키로 명령어 이력을 살펴볼 수 있는 것을 알아봤다.
이 명령어 이력은 홈 디렉토리 내부에 .bash_directory에 저장된다.

```bash
history | less
```

대개 명령어 500개에서 1000개 정도를 저장한다. 

```bash
history | grep /usr/bin
```

```bash
88 ls -l /usr/bin > ls-output.txt
```

여기서 88은 이력에서 명령어의 줄번호를 말한다. 우리는 이 88을 가지고
history expansion을 할 수 있다. 이력 확장인 셈이다.

```bash
!88
```

입력해보면 해당 명령어가 실행된다.

history 내역을 가지고 특정 명령어를 검색하는 것도 가능하다. Ctrl + R을
누른 다음 예를 들어 ls -l 과 같이 특정 명령어를 검색하면 검색이 가능하다.
검색이 된 다음 엔터를 누르면 실행이 가능하다. 또는 Ctrl + j를 누르면 현재
커맨드 라인으로 복사가 된다. 그 상태에서 Ctrl + r을 계속 눌러주면 다음 명령어
를 계속 확인할 수 있다. 
Ctrl + g 그 다음 Ctrl + c를 누르면 종료가 된다.

다음은 history 관련 명령어다.

Ctrl + p : 이전 명령어 보기
Ctrl + n : 다음 명령어 보기
Alt + <- : history의 처음으로 가기
Alt + -> : history의 끝으로 가기
Ctrl + r : history에서 명령어 찾기(순차적으로)
Alt + p : history에서 명령어 찾기(뒤에서부터)
Alt + n : history에서 명령어 찾기(앞에서부터)

## history expansion

다음은 history expansion 관련 명령어다.

!! : 마지막 명령어를 반복한다.
!number : history list에서 해당 번호의 명령어를 반복한다.
!string : history list에서 해당 string으로 시작하는 명령어를 반복한다.
!?string : history list에서 해당 string을 포함하는 명령어를 반복한다.

참고) script

리눅스 내의 대부분의 프로그램을 스크립트라고 한다.
다음과 같이 실행된다.

script [file]

# Chapter9. Permission

MS-DOS 계열의 윈도우와 유닉스 계열의 리눅스의 큰 차이점은 MS-DOS 계열은 멀티 태스킹 시스템도
아니고, 멀티 유저 시스템도 아니다. 멀티 유저 시스템이라는 말은 동시에 한 명 이상이 컴퓨터를 사용
할 수 있다는 말이다. 하나의 컴퓨터는 키보드와 모니터를 가지지만 한 명 이상이 사용하는 것은 충분히
가능하다. 예를 들어, 네트워크나 인터넷에 연결된 컴퓨터라면, 원격 사용자가 ssh(secure shell)을 통해
로그인해서 컴퓨터를 조작할 수 있다.

리눅스의 멀티 유저 지원은 최근의 혁신이 아니라 운영체제 설계부터 깊이 내장된 기능이다. 애초에 컴퓨터는
개인용이 되기에는 매우 크고 비쌌다. 원래는 중앙 컴퓨터에 단말기를 통해 접속하는 방식이었다.

그러다 보니 한 사용자를 다른 사용자로부터 보호하기 위한 방법이 필요했고, '권한' 개념이 필요했던 것이다.

## Owners, Group members, And Everybody else

```bash
less /etc/shadow
```

위와 같이 입력하면 허가 거부가 출력된다. 일반 사용자이기 때문이다. 각 사용자는 파일과 디렉토리를 소유하고
접근 권한을 제어할 수 있다. 그리고 각 사용자는 한 명 이상으로 구성된 그룹에 속할 수 있다.

```bash
id
```

위와 같이 입력하면 사용자ID를 파악할 수 있다. 사용자 계정이 생성되면 사용자 ID를 할당받는다. 또, 주그룹 아이디(gid)
를 할당받고 다른 그룹에 속할 수도 있다. 

이런 정보들은 사용자 계정은 /etc/passwd, 그룹은 /etc/group, 비밀번호는 /etc/shadow 등에 저장된다.

## Reading, Writing and Executing

ls -l 로 디렉토리 내부의 정보를 파악할 수 있었다.
출력되는 처음 10개의 문자는 파일 속성을 말한다.
첫 문자는 파일 종류, 나머지 문자는 9개의 문자는 파일 모드라고 부른다.
파일 모드는 파일 소유자, 파일 그룹, 기타 사용자에 대한 읽기, 쓰기, 실행하기 권한을 나타낸다.

참고)
파일의 종류

\- : 일반 파일
d : 디렉토리
l : 심볼릭 링크
c : 문자 특수 파일
b : 블록 특수 파일

파일의 속성

r : 파일의 읽기와 열기 허용
w : 파일 쓰기 또는 잘라내기 허용 / 파일 변경이나 삭제는 허용x 
    / 삭제나 파일명 변경은 디렉토리 속성에 의해 결정
x : 파일의 실행을 허용

### chmod

chmod 명령어로 위에서 이미 설정된 파일 모드를 변경하는 것이 가능하다.
방법은 크게 두 가지다.
* 8진법 표현
  ex) 0 -> 000 -> ---
  ex) 2 -> 010 -> -w-
  ex) 7 -> 111 -> rwx
* 기호 표현 
  * u(user) : 파일/디렉토리 소유자
  * g(group) : 그룹 소유자
  * o(others) : 기타 사용자
  * a(all) : u,g,o의 조합
  ex) u+x : 소유자에게 실행 권한 추가
  ex) u-x : 소유자에게 실행 권한 제거
  ex) u+x, go=rw : 소유자에게 실행 권한을 추가하고, 그룹 소유자와 기타 사용자에게
      읽기, 쓰기 권한을 설정

### umask 

umask 명령어로 파일이 생성될 때 그 파일의 default 퍼미션을 제어할 수 있다. 
umask 명령어로 현재의 umask값을 확인할 수 있다. 
> 0022

동작하는 방식을 살펴보면

원래 파일 모드 --- rw- rw- rw-
마스크        000 000 000 010
결과          --- rw- rw- r--

마스크에 1이 나타나는 곳을 보면 속성이 제거되어 있는 것을 확인할 수 있다.

참고) 권한 자동 설정
출처 : http://brothernsister.tistory.com/35

## Changing Identities

다양한 상황에서 다른 사용자의 ID가 필요할 수 있다. 방법은 세 가지다.
* 로그아웃 후 다른 사용자로 로그인(편의성 부족)
* su 명령어 사용하기(다른 사용자의 ID로 상정)
* sudo 명령어 사용하기(다른 사용자의 권한을 가지고 특정 명령어 실행)

### su

* 다른 사용자로 쉘을 시작하기 위해 사용
* su [-l] [user] 
* -l 옵션을 사용하면 이 명령에 지정된 사용자의 홈 디렉토리로 변경되어 시작한다.
* 만약 사용자를 지정하지 않으면 슈퍼유저를 가정한다.
* -l는 - 로 줄여서 사용하는 것이 가능하고 대부분은 -로 줄여서 사용한다
* exit으로 빠져나올 수 있다.
* su -c 'ls -l' 와 같이 c 옵션을 주면 단일 명령 행이 새로운 쉘에 전달된다.

### sudo

* su와 비슷하지만 중요한 추가기능이 있음
* 사용자가 sudo를 붙여서 실행할 때 하나 이상의 지정된 명령어로 제한되고 나머지는 불가하다.
* su와 중요한 차이는 슈퍼 유저의 비밀번호를 요구하지 않는다는 것이다.
  대신 sudo 사용을 입증하기 위해 사용자는 단지 자신의 비밀번호를 입력한다.
* su와 sudo의 또다른 차이점은 sudo는 새로운 쉘에서 시작하지 않는다는 것이다. 다른 사용자의 환경을
  로드하지도 않는다.

참고) 
* permission denied 메세지를 그저 피하기 위해 시스템을 root 사용자로 운영하는 것은 그리 좋은 생각이 아니다.

### chown 

chown 명령어는 파일 또는 디렉토리의 소유자와 그룹 소유자를 변경하는 데 사용된다.

chown의 arguments 예제
* bob : 파일의 소유권을 현 소유자에서 bob으로 변경
* bob:users : 파일의 소유권을 현 소유자에서 bob으로 변경하고 파일 그룹 소유자를 users그룹으로 변경
* :admins : 파일 소유자 그룹을 admins 그룹으로 변경
* bob: : 파일 소유자가 bob으로 변경되고 그룹 소유자는 bob의 로그인 그룹으로 변경

### chgrp 

그룹 소유권을 변경하기 위한 독립된 명령어이고 chown과 유사하게 동작한다.

## Changing Your Password

passwd [user]

```bash
passwd
```

위와 같이 명령어를 입력하면 이전 비밀번호와 새 비밀번호 입력을 위한 표시가 띄고 비밀번호를 변경할 수 있다.
슈퍼유저 권한을 가지고 있다면 passwd 명령의 첫 인자에 사용자 이름을 지정해서 그 사용자의 비밀버놓를 설정할
수 있다.

# Chapter10. Processes

현대 운영체제들은 한 프로그램에서 다른 프로그램으로 빠르게 이동함으로써 하나 이상의 작업이 실행되는 듯한 환상을 
심어주는 멀티태스킹 방식이다. 리눅스 커널은 프로세스를 통해 이를 관리한다. 프로세스란 리눅스가 CPU를 사용하기 위해
차례를 기다리는 각 프로그램을 구조화한 것이다.

## How A Process Works

* 시스템이 구동될 때 : 커널 -> 몇몇 프로세스 초기화 / init 프로그램 실행
                             (init 프로그램 -> init 쉘 스크립트 실행)
* 많은 서비스들은 데몬 프로그램으로 구현됨
  * 데몬 프로그램 : 사용자 인터페이스 없이 백그라운드 상태로 실행
                   로그인하지 않은 상태에서 최소한의 필요한 작업들을 수행
* 프로그램은 또 다른 프로그램 실행 가능
  * 부모 프로세스 -> 자식 프로세스 생성
* 커널은 구조화된 형태로 프로세스 정보 유지
  * 프로세스 ID(오름차순/PID 1번은 항상 init) 등등
  * 실행 재개를 대기 중인 프로세스도 포함 -> 각 프로세스에 할당된 메모리 공간 유지

### ps 명령어로 프로세스 보기

현재 터미널 세션과 관련된 프로세스만 간단하게 보기

```bash
ps
```

시스템 전체 실행상황 보기

```bash
ps x
```

참고) 
TTY(teletype) : 프로세스용 제어 터미널 (?면 없다는 말)
STAT(state) : 상태
  * R : 실행 상태
  * S : 수면 상태(키 입력 등의 이벤트를 기다리는 상황)
  * D : 인터럽트 불가능한 수면 상태(디스크 입출력 등)
  * T : 종료 상태
  * Z : 좀비 프로세스(부모 프로세스에 의해 정리되지 않은 자식 프로세스)
  * < : 높은 우선순위 프로세스(CPU 시간을 더 줄 수 있다.)
  * N : 낮은 우선순위 프로세스
       (높은 우선순위 프로세스가 사용한 뒤 프로세서 시간 획득 가능)

모든 사용자에 속한 프로세스 보기

```bash
ps aux
```

헤더의 의미
* USER : 사용자 ID
* %CPU : CPU 사용량
* %MEM : 메모리 사용량
* VSZ : 가상 메모리 크기
* RSS : 사용 메모리 크기
* START : 프로세스가 시작된 시각

### top 명령어로 프로세스 변화 보기

top 명령어를 통해 시스템의 활동을 더욱 동적으로 확인 가능하다.
(3초마다 갱신)



헤더의 의미
* load average(평균 부하) : 실행 대기중인 프로세스 수
* 0.7%us : 사용자 프로세스들이 CPUdml 0.7%를 사용 중이라는 말
* 1.0%sy : CPU의 1.0%를 시스템(커널) 프로세스에서 사용 중이라는 말
...

## Controlling Processes

1) 프로세스 인터럽트하기

Ctrl + c 입력을 통해 프로세스를 중단시킬 수 있다.(인터럽트)

2) 프로세스를 백그라운드로 전환

프로세스는 화면에 표시되는 상태인 포어그라운드와 화면 뒤에 숨겨진 상태인 
백그라운드 상태가 있다.

```bash
xlogo &
```

위 명령어를 통해 백그라운드에서 실행이 가능하다.
화면에는 보이지 않지만 ps 명령어와 jobs 명령어롤 살펴보면 실행 중이라는 것을
알 수 있다.

3) 프로세스를 포어그라운드로 전환

```bash
fg %1
```
1번 작업을 포어그라운드로 전환하겠다는 뜻이다.
fg + %작업번호 를 사용하고 하나의 백그라운드 작업만 있다면 작업번호는 
생략이 가능하다.

3) 프로세스 정지

종료가 아니라 잠시 멈추고 싶을 때가 있을 것이다. Ctrl + Z 명령을
누르면 된다.
정리된 상태에서 fg나 bg 명령어로 포어그라운드 또는 백그라운드로 
전환하는 것이 가능하다.

## Signal 

### kill로 시그널 보내기

kill 명령어는 프로세스를 종료하기 위해 사용하는데 다음과 같이
사용할 수 있다.

```bash
kill 28401
```

kill 명령어는 정확히는 프로세스를 kill 즉 종료하지 않는다. 프로세스에
시그널 즉 신호를 보낼 뿐이다. 프로그램은 그 시그널을 받고 그에 따라
행동을 하는 것이다.

kill 명령어를 조금 더 살펴보면

kill [-signal] PID ...

signal 옵션을 명시해주지 않으면 default 값은 TERM(종료) 시그널을 보낸다.
주요 시그널(-signal)
KILL : 커널이 강제 종료
HUP : 재시작하고 환경설정 파일을 다시 읽어 들이게 됨
INT : 인터럽트
TERM : 종료 시그널 보냄
STOP : 정지
CONT : 다시 복원

참고)
kill -l 을 통해 전체 시그널 목록을 볼 수 있다.

## killall로 다수의 프로세스에 시그널 보내기

killall [-u user] [-signal] name ...

명시된 프로그램 또는 사용자 이름과 일치하는 다수의 프로세스에서
시그널 보내는 것도 가능

```bash
killall xlogo
```

## 기타 프로세스 관련 명령어들

프로세스를 모니터링하는 것은 중요한 시스템 관리 업무이기 때문에 많은 명령어들이 존재
* pstree : 프로세스간 부모/자식 관계를 보여주는 트리 형태로 정렬해서 프로세스 목록을 출력
* vmstat : 메모리, 스왑, 디스크 I/O를 포함한 시스템 자원 사용 현황을 출력
* xload : 시간에 따라 시스템 부하를 그래프로 보여주는 그래픽 프로그램
* tload : xload와 유사하지만 터미널에서 그래프를 보여준다.

