# The Linux Command Line Part1 - Learning the Shell


# Introduction에 나오는 인상 깊은 문장들

"Freedom is the power to decide what your computer does, and the only way to have this freedom is to know 
what your computer is doing. Freedom is a computer that is without secrets, one where everything can be known 
if you care enough to find out."

"It's been said that “graphical user interfaces make easy tasks easy, while command line interfaces make difficult 
tasks possible” and this is still very true today."


# Chapter1. What is a Shell?

Shell을 영어사전에 검색하면 조개껍데기, 껍질과 같은 뜻이 나온다. 이는 운영체제의 동작을 통제하는
프로그램인 커널의 외부 형태이기 때문이다. 쉽게 말하면 사용자가 운영체제와 소통하기 위한 인터페이스라고
생각하면 된다. 꼭 Command line의 형태이어야 하는 것은 아니고 Graphical한 형태일 수도 있다. 
커맨드 라인이라면 간단하게 keyboard 입력을 받아서 os가 실행한다고 생각해도 무관하다.

## terminal 형태

User@ComputerName:

@ 앞의 User 자리에 현재 사용자의 이름이 들어가고 ComputerName 자리에 컴퓨터이름이 들어간다. 

## Command history

터미널에서 윗쪽 화살표 키를 입력하면 기존에 입력했던 명령어들을 확인할 수 있다. 계속 눌러보면
기존에 입력했던 명령어들이 하나씩 보이는 것을 볼 수 있다. 그리고 다시 아래쪽 화살표를 누르면
입력했던 명령어 다음에 입력했던 명령어를 볼 수 있다. Command history 즉 명령어 이력을 확인할 
수 있다.

## 간단한 명령어들

date : 현재 날짜와 시간을 출력한다.
cal : 달력 형태로 날짜와 시간을 보여준다.
df : 디스크의 빈 공간을 확인할 수 있다.
free : 메모리의 빈 공간을 확인할 수 있다.
exit : 종료

df, free와 같은 명령어들에서 굉장히 편하게 현재 컴퓨터의 정보를 파악할 수 있다는 것을 느낄 수 있다.

## 가상 콘솔


# Chapter2. Navigation

리눅스에서는 어떻게 파일 시스템을 옮겨 다닐 수 있을까?

중요한 명령어는 pwd, cd, ls이다.
* pwd(print working directory)
* cd(change directory)
* ls(list directory contents)

어떤 말의 약어인지 파악하면 감이 온다.

리눅스의 파일 시스템은 트리의 형태를 띄고 있다. 윈도우와 다르게 하나의 트리, 하나의 계층적 구조를 가진다.
저장장치와 상관이 없다. 저장장치는 관리자의 의도에 따라 붙였다(mount) 떼어냈다가 할 수 있을 뿐이다.

처음 리눅스 파일 시스템을 익히는 입장에서는 트리 형태의 미로라고 생각하면 된다. 트리의 어디쯤 위치하고
있는지 알고 싶을 때 사용하는 명령어가 pwd다. 즉 현재 위치하고 있는 디렉토리를 확인할 수 있다.

pwd(print working directory)

cf) 처음 log in을 하면 home directory에서 시작한다. 각 계정마다 home directory가 있고 그 디렉토리가
그 User가 쓰기 작업을 할 수 있는 유일한 공간이다.

어떤 가지가 붙어있고 어디로 갈 수 있는지 확인하는 명령어가 ls이다. 어떤 디렉토리와 연결되어 있는지
확인할 수 있다.

ls(list directory contents)

그리고 실제로 옮겨가는 명령어가 cd다. 

cd(change directory)

cd (pathname)

pathname 자리에 옮겨갈 경로의 이름을 넣어주면 된다. 

이 때 경로의 이름을 적어주는 2가지 방법이 있는데 바로 절대경로와 상대경로다.

두 경로의 차이는 기준이 무엇인가 하는 것이다. 

먼저, 절대경로는 root directory를 기준으로 한다. root directory는 트리의 가장 상단에 위치하는
디렉토리를 말한다. 그래서 절대경로를 사용해서 디렉토리를 옮기려면 root directory에서부터 옮기려는
디렉토리명이나 파일명까지 입력해주면 된다.

```bash
cd /usr/bin
```

위의 /usr/bin에 가장 앞에 오는 / (슬래시 기호)는 root directory를 뜻한다. 그래서 root 디렉토리 하위의
 usr 디렉토리 하위의 bin 디렉토리로 이동하겠다는 뜻이다.

두번째, 상대경로는 기준이 현재 작업하고 있는 디렉토리가 된다. 

```bash
cd .
cd .. 
```

.(점/dot)은 현재 작업하고 있는 디렉토리를 말한다. 
..(점점/dotdot)은 현재 작업하고 있는 디렉토리의 바로 상위 디렉토리를 말한다.
그래서 위 명령어는 현재 디렉토리라는 명령어 그리고 상위 디렉토리로 이동하라는
뜻이 된다.

```bash
cd ./bin
cd bin
```

그리고 위 명령어에서 cd ./bin 즉 현재 디렉토리의 하위 디렉토리인 bin 디렉토리로 이동하라는 명령어는
./ 을 생략하고 사용하는 것이 가능하다.

cf) 도움이 되는 단축키들

```bash
cd ~ 
cd -
cd ~user_name
```
위 명령어는 위에서부터 
cd ~ : home directory로 이동하라
cd - : 이전에 작업하던 디렉토리로 이동하라
cd ~user_name : user_name에 해당하는 사용자의 home directory로 이동하라

cf) 리눅스 파일 시스템에서의 주의사항
* 파일명에 .(점/dot)이 붙는 경우 숨김 파일이다. 즉 ls 명령어를 입력해도 안 보인다.
  ls -a를 입력하면 된다.
* 리눅스는 대소문자를 구분한다.
* Linux는 파일 확장자 개념이 없다!
  어떻게 이름을 지어도 상관 없지만 응용프로그램의 경우 대개 확장자명을 붙인다.
* 파일명에 스페이스를 넣지 말도록 한다. 나중에 후회한다. _(underscore)를 사용하도록 한다.
  리눅스 파일시스템에서 따로 막지는 않지만 사용하지 않는 것이 좋다. 확인해보니 공백 이전까지만
  파일명을 인식한다. ex) test space -> test


# Chapter3. Exploring The System

## ls 더욱 살펴보기

아래는 시스템을 탐색하는 데 도움이 되는 세 가지 명령어다.
* ls(List directory contents)
* file(Determine file type)
* less(View file contents)

그냥 ls만 입력해서 사용하는 것도 가능하지만 다음과 같이 사용하는 것도 가능하다.
ls (pathname)

```bash
ls /usr
```
위와 같이 입력하면 /usr 디렉토리의 하위 내용을 출력할 수 있다.

```bash
ls ~ /usr
ls ~/ready ~/ready/dudaji/usr
```
와 같이 두 개 이상의 디렉토리에 대해서도 가능하다.

또 상세히 하위 내용을 출력하는 것도 가능하다. 다음과 같이 입력하면 된다.

```bash
ls -l
```

위 명령어를 살펴보면 하나 또는 그 이상의 옵션과 인자를 줄 수 있다.
대부분은 아래와 같은 형식이다.

command -options arguments

옵션을 여러 개 주는 것도 가능한데 다음과 같이 작성하는 것도 가능하다.

```bash
ls -lt
```

위 lt에서 l은 상세히 출력하는 long format option이고, t는 파일의 수정시간 순으로
정렬하여 출력하는 옵션이다.
(확인해보니 나중에 수정한 것이 위에 온다.)

```bash
ls -lt --reverse
```

위의 명령어에서 --reverse 옵션을 주면 순서가 뒤집힌다.

ls 명령어의 옵션은 --reverse와 같이 long option을 주거나 -r로 축약해서 주는 것 
모두 가능하다.

그러므로 다음과 같이 표현하는 것도 가능하다.

```bash
ls -ltr
```

ls -l로 상세히 특정 디렉토리의 하위 내용을 출력했을 때 그 내용을 제대로 살펴보는 것도
시스템을 탐색하는데 도움이 된다.

맨 왼쪽에는 다음과 같은 기호가 있다.

-rw-r--r--

총 10개의 문자인데 /(슬래시)를 기준으로 나누어서 파악할 수 있다.

\- / rw- / r-- / r-- 

맨 처음에 오는 -(dash)는 내용의 type을 말한다. 이 경우 - (dash)가 적혀있는 경우
파일이라는 뜻이다. d는 디렉토리를 말하고 이 두 가지 말고도 다른 type이 될 수 있다.

\- / rw- / r-- / r-- 

타입 / 파일 소유자의 권한 / 그룹 멤버의 권한 / 모든 사용자의 권한

2번째 칸의 rw-는 파일 소유자의 권한을 말한다.
이 경우 r(read), w(write)의 접근 권한을 가지고 있는 것이다.

이 10개의 문자 다음으로 오는 1은 하드 링크들의 파일 번호(File's number of hard links)
를 말한다.

그 다음 차례대로 다음과 같이 연결된다.

root / root / 32059 / 2007-04-03 11:05 / oo-cd-cover.pdf

소유자 / 그룹명 / 파일사이즈 / 수정날짜 / 파일명

## Determining A File Type with file 

시스템을 탐색하면서 수많은 파일을 보게 되는데 파일의 내용이 어떤 내용인지 알 수 있다면 
좋을 것이다. 이때 사용하는 것이 file 명령어다. 앞서 살펴봤듯이 리눅스에서는 파일명이 
파일 내용을 반영하지 않는다. 확장자 개념이 없다. 그러므로 file 명령어를 사용하면 해당
파일에 대한 간단한 내용을 파악할 수 있다.

```bash
file scheduler.py
```

사실 파일의 종류는 다양하고 리눅스와 같은 유닉스 계열의 운영체제는 "Everything is a file"
(모든 게 파일이다.)이다.

## Viewing File Contents with less

less는 텍스트 파일을 확인할 때 사용하는 명령어다. 파일의 종류는 다양하고 그 중 많은 텍스트 파일이
있다. less 명령어는 이런 텍스트 파일을 확인할 때 유용하게 사용할 수 있다.

텍스트 파일을 확인하는 것이 중요한 이유는 다양한 시스템 설정 파일 그리고 시스템이 실행하는 스크립트 
파일이 텍스트 형태로 되어 있기 때문이다. 이런 텍스트 파일을 잘 이해하는 것은 시스템이 어떻게 동작하는지
파악하는데 큰 도움이 된다.

```bash
less scheduler.py
```

## Linux File System

리눅스 파일 시스템은 대부분의 유닉스 계열 운영체제의 파일 시스템과 유사하다. 모든 리눅스 운영체제가
Linux Filesystem Hierarchy Standard를 따르고 있는 것은 아니지만 대부분은 따르고 있다.

루트 디렉토리에서 시작해서 각각의 디렉토리가 어떤 내용을 담고 있는지 살펴보면 파일 시스템의 구조를 
살펴보는데 큰 도움이 된다.

## Symbolic Link

ls -l 명령어로 정보를 살펴봤을 때 type이 l이고 파일명이 화살표로 다른 파일명을 가리키고 있는 형태를
종종 볼 수 있다. 이런 종류의 파일을 Symbolic Link라고 한다. 리눅스에서는 하나의 파일이 다양한 이름에
의해 참조될 수 있다. 굉장히 유용한 기능이다.

예를 들어 하나의 파일을 공유하고 있고 그 파일이 변경이 잦다고 한다면 문제가 생길 수 있다. 예를 들어 그 
파일을 참조하는 다양한 프로그램은 그 파일의 파일명이 변경될 때마다 프로그램 내에서의 이름을 바꾸어주어야
한다. 그런 불상사를 막기 위해 심볼릭 링크라는 형태의 파일이 생긴 것이다. 말그대로 링크 파일 즉 연결된 파일을
생성하는 셈이다. 그 링크 파일을 열면 사실상 그 파일과 연결된 원래 파일이 참조된다. 이렇게 되면 변화를 수용하기
쉽다. 포인터만 바꾸어주면 되는 셈이다.


# Chapter4. Manipulating files and directories

아래는 파일 시스템 내의 파일과 디렉토리를 다룰 수 있는 명령어다.
* cp : 파일과 디렉토리를 복사한다.
* mv : 파일과 디렉토리를 이동시키거나 이름을 변경한다.
* mkdir : 디렉토리를 생성한다.
* rm : 파일과 디렉토리를 삭제한다.
* ln : 하드 링크와 심볼릭 링크를 생성한다.

그래픽 유저 인터페이스에서 처리하는 것이 더 쉽지 않은가라고 생각할 수도 
있지만 한 디렉토리 내 모든 html 파일을 다른 폴더로 옮기거나 특정 조건의
파일만 다른 디렉토리만 옮기는 등의 작업은 그래픽 유저 인터페이스에서 처리하는
것이 쉽지 않다.

## 와일드카드

빈번하게 사용하는 위 5개 명령어를 익히기 전에 알아두면 좋은 것, 날개를 달아주는
것이 와일드카드다.

와일드카드를 이용해서 특정 파일명의 파일을 한꺼번에 선택하는 것이 가능하다.

\* : 일치하는 모든 문자열
? : 일치하는 하나의 문자
[characters] : [] 안에 있는 문자 집합의 원소에 일치하는 것
[!characters] : [] 안에 있는 문자 집합의 원소에 일치하지 않는 것
[[:class:]] : 특정 클래스의 집합에 일치하는 문자
  * [:alnum:] : 영문과 숫자
  * [:alpha:] : 영문
  * [:digit:] : 숫자
  * [:lower:] : 소문자
  * [:upper:] : 대문자

  와일드카드를 사용한 예)
  * \* : 모든 파일
  * g* : g로 시작하는 모든 파일
  * b*.txt : b로 시작하는 텍스트 파일
  * [abc] : a 또는 b 또는 c로 시작하는 모든 파일
  * Backup\[0-9\]\[0-9\]\[0-9\] : Backup.뒤에 0부터 9까지의 숫자 중 하나가 세 개 있는 문자

파일명을 인자로 받는 모든 명령에 적용 가능하기 때문에 굉장히 강력하다고 할 수 있다.

## mkdir

와일드카드를 알아본 다음 가장 먼저 알아볼 명령어는 mkdir이다.

```bash
mkdir dir1
mkdir dir1 dir2 dir3
```

디렉토리를 생성하는 명령어이고 위의 명령어처럼 한꺼번에 여러 디렉토리를 생성하는 것도 가능하다.

## cp

복사하는 명령인 cp는 두 가지 방법이 있다. 하나는 

```bash
cp item1 item2
```

하나의 디렉토리 또는 파일을 다른 디렉토리 또는 파일로 복사하는 방법이다.

두 번째 방법은 여러 개의 파일이나 디렉토리를 하나의 디렉토리로 복사하는 방법이다.

```bash
cp item1 item2 ... directory
```

cp에는 옵션이 다양하다. 여기서 나오는 옵션들은 뒤에서도 공통적으로 나오는 옵션들이 많다.
* -a(--archive) : 권한을 포함한 모든 것이 복사된다.
* -i(--interactive) : 덮어쓰기 전에 사용자에게 확인을 받는다. 옵션을 안 주면 그냥 덮어쓴다.
* -r(--recursive) : 재귀적으로 디렉토리와 파일을 복사한다. 디렉토리 자체는 디렉토리 안에 
또 다시 디렉토리가 있는 재귀적인 구조이기 때문에 디렉토리를 복사하기 위해서는 이 recursive
옵션을 설정해주어야 한다.
* -u(--update) : 복사하려는 디렉토리에 파일이 없거나 변경이 있는 파일만을 복사한다.
* -v(--verbose) : verbose를 영어사전에 검색하면 '장황한'과 같은 뜻이 나온다. 복사를 진행할 때
진행하는 작업에 대한 내용을 텍스트로 보여준다.

cp 작업의 예)
* cp file1 file2
* cp -i file1 file2
* cp file1 file2
* cp file1 file2 dir1
* cp dir1/* dir2
* cp -r dir1 dir2

## mv 

cp와 마찬가지다. 두 가지 방법이 있다.

파일 이름 또는 디렉토리명을 변경하거나 디렉토리나 파일을 이동시킬 때 사용 가능하다.

```bash
mv item1 item2
```

하나 이상의 디렉토리나 파일을 다른 디렉토리로 이동시킬 때 사용하는 것도 가능하다.

```bash
mv item1 item2 ... directory
```

cp와 마찬가지로 옵션을 주는 것이 가능하다.

# rm 

```bash
rm item ...
```

하나 또는 하나 이상의 디렉토리나 파일을 삭제하는데 사용한다.

rm 역시도 옵션을 공유한다. 특히 삭제할 때 디렉토리의 경우

-r(--recursive) 옵션을 주어야 삭제가 가능하다. cp와 같은 이유다.

그리고 앞에서 보지 못한 

-f(--force) 옵션이 있는데 이는 존재하지 않는 파일을 지우려고 해도 무시하고
계속 다른 작업을 진행하라는 말이다. -i(--interactive) 옵션을 줘도 -f 옵션을
주면 그냥 무시하고 진행한다. -i 옵션을 덮어쓴다고 생각하면 된다.

그리고 rm 명령어를 사용할 때는 특히 주의해야 한다. 윈도우처럼 휴지통에 갔다가 지워지는 것이
아니라 그냥 끝이다. 못 되돌린다. 신중하게 그리고 주의해서 사용하도록 해야 한다.

## ln 

하드 링크나 심볼릭 링크를 생성하는 명령어다.

```bash
ln file link
```

위는 하드 링크를 생성하는 명령어다. 그리고 아래는 심볼릭 링크를 생성하는 명령어다.

```bash
ln -s item link
```

item은 파일일 수도 있고 디렉토리일 수도 있다.

## 하드 링크(Hard Link)

모든 파일은 기본적으로 하나의 하드 링크를 가진다. 그런데 하드 링크를 하나 더 만들어주면
파일을 가르키는 화살표가 하나 더 생기는 셈이다.

->(1) file (2)<-  

원래 파일을 가르키는 (1)번 화살표만 있었는데 (2)번 화살표를 생성해서 접근할 수 있는 수단을
하나 더 만들어주는 셈이다. 복사본이 하나 더 생기는 셈이 아니라 실제 파일을 가르키는 화살표가
하나 더 생기는 셈이기 때문에 1번 화살표와 2번 화살표는 동등하다.

하드 링크의 문제점은 파일 시스템 외부에서는 참조할 수 없다는 것이다. 즉 디스크 내의 같은 파티션이
아니면 참조할 수 없다.

그리고 하드 링크는 디렉토리를 참조하지 않을 수 있다. 하드 링크가 만약 지워지면 그 파일을 가리키는 
하드 링크가 존재하는 한 남아있는다. 파일을 가르키는 모든 하드 링크가 삭제되면 그때 사라진다.

## 심볼릭 링크(Symbolic link)

심볼릭 링크는 하드 링크의 문제점을 보완하기 위해 생겼다. 심볼릭 링크가 생성되면 심볼릭 링크는 
참조할 파일이나 디렉토리를 가르키는 텍스트 포인터가 담기는 파일을 생성한다. 윈도우의 바로가기
아이콘처럼 생각하면 된다. 사실 리눅스에 더 먼저 있었던 셈이다.

윈도우에서 바로가기 아이콘을 열어서 해당 파일를 수정하면 그 파일의 내용은 수정된다. 하지만 그
바로가기 아이콘을 지운다고 그 파일 자체가 지워지는 것은 아니다.

그림으로 생각해보면

file <-(1) text pointer file <-(2)

이런 식이 되는 것이다. 2번 화살표를 통해 접근하면 포인터를 통해 실제 파일에 접근할 수 있다.
하지만 2번 화살표가 지워진다고 실제 파일이 사라지는 것은 아니다. 그냥 가리키고 있던 화살표가
하나 지워지는 셈이다.

하드 링크와 심볼릭 링크의 차이점
출처 : http://junsik.tistory.com/34


# Chapter5. Working with commands

무언가를 실행하는 명령에 익숙하지만 명령 자체에 대한 명령도 있다.

명령어를 계속 사용해왔는데 명령어가 정확히 뭘까?

네 가지 정도로 생각해볼 수 있다.
* 실행 가능한 프로그램 ex) c++로 작성된 프로그램
* shell 자체에 내장된 명령어
* shell 스크립트 함수
* alias(다른 명령어에 대해 다른 이름으로 tag를 붙여둔 명령어)

명령어에 대한 명령어를 나누면 크게 세 가지다.
* 명령어에 대해 알아보는 명령어 
* 명령어에 대한 문서를 확인하는 명령어
* 사용자가 정의하는 명령어

## 명령어에 대해 알아보는 명령어

1) type : 어떤 종류의 명령이 실행될지 살펴보는 명령어

```bash
type ls
```

2) which : 시스템 내 설치된 어떤 명령이 실행될지 확인하는 명령어

```bash
which python
which python3
```

## 명령어에 대한 문서를 확인하는 명령어

1) help (명령어) : 명령어를 어떻게 사용하는지 용법을 보여준다.

```bash
help cd
```

```bash
mkdir --help
```

2) man (명령어) : 해당 명령어 즉 프로그램에 대한 매뉴얼을 보여준다.

```bash
man ls
```

man 명령어를 사용하면서 참고할 부분은 매뉴얼에 레이아웃이 있어 섹션이
나누어져 있다는 것이다. 아래와 같이 1번은 User commands고 2번은
Programming interfaces for kernel system calls이다.

1 User commands
2 Programming interfaces for kernel system calls
3 Programming interfaces to the C library
4 Special files such as device nodes and drivers
5 File formats
6 Games and amusements such as screen savers
7 Miscellaneous
8 System administration commands

그런데 man 명령을 하면서 섹션을 명시해주지 않으면 항상 가장 처음 일치하는
명령을 반환하기 때문에 계속 1번 섹션의 명령어만 참조되는 불상사가 생길 수 있다.

man section search_term

위와 같은 형식으로 명령을 내려주면 된다. 예를 들면 다음과 같다.

```bash
man 5 passwd
```

3) apropos : man에서 특정 검색어와 일치하는 관련 명령어를 반환하는 명령어

```bash
apropos floppy
```

4) whatis : 그 명령어의 정보를 한 줄 설명으로 보여주는 명령어

```bash
whatis ls
```

5) info : 리눅스에서는 man 명령어로 볼 수 있는 매뉴얼 말고도 info 명령어로 
정보를 볼 수 있다. 각각의 문서는 하나의 주제로 되어 있고 하이퍼링크로 연결되어
있다.

```bash
info coreutils
```

## 사용자가 정의하는 명령어

alias를 통해 원하는 명령어를 정의할 수 있다. 

예를 들어 다음과 같이 명령어를 한꺼번에 3개를 실행한다고 생각해보자.

```bash
cd /usr; ls; cd -;
```

그리고 이러한 명령어를 빈번하게 사용해야한다고 생각해보자. 그러면 alias로 
세 연속된 명령어에 대해 새로운 별칭을 줘서 간결하게 실행하는 것이 가능하다.

대신 alias를 적용하기 전에 먼저 그 명령어의 이름이 정의되어 있는 것은 아닌지
확인해보는 것이 필요하다.

type 명령어로 확인해보면 된다. 예를 들어 test 명령어의 경우 이미 정의가 되어
있다. 그러니 예를 들어 foo라는 이름을 type으로 먼저 확인해보고 그 이름을
이용해서 정의해주면 된다.

```bash
alias foo='cd /usr; ls; cd -;'
```

alias (새로 정의할 이름) (명령어 문자열)

형식으로 정의하면 된다. 그 다음부터는 새로 정의한 이름만 입력해도 명령어가 실행된다.
이 경우 foo만 입력해도 명령이 실행된다. alias를 해제하려면 다음과 같이 해제해주면 된다.

```bash
unalias foo
```

그리고 type 명령어로 제대로 해제가 되었는지 확인하는 것도 가능하다.

참고로 alias만 입력하면 설정된 alias를 확인할 수 있다.

